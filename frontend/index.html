<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omnix AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Georgia, 'Times New Roman', Times, serif;
            background: #f7f7f5;
            color: #1a1a1a;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Main Content Container */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-left: 260px;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            left: -260px;
            top: 0;
            width: 260px;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e5e5e5;
            z-index: 1000;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-close {
            background: none;
            border: none;
            padding: 0.25rem;
            cursor: pointer;
            color: #666;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sidebar-close:hover {
            background: #f0f0f0;
            color: #1a1a1a;
        }

        .new-chat-btn {
            background: #c17b47;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .new-chat-btn:hover {
            background: #a66939;
        }

        .chat-history-section {
            flex: 1;
            overflow-y: auto;
            padding: 0 1rem;
        }

        .chat-history-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            margin: 1rem 0 0.5rem 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .chat-item {
            padding: 0.75rem 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 0.25rem;
            border-left: 3px solid transparent;
        }

        .chat-item:hover {
            background: #f8f8f8;
            border-left-color: #c17b47;
        }

        .chat-item.active {
            background: #f0f0f0;
            border-left-color: #c17b47;
        }

        .chat-item-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            margin-bottom: 0.25rem;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .chat-item-time {
            font-size: 0.75rem;
            color: #666;
        }

        /* Sidebar Mini Version */
        .sidebar-mini {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 0.75rem 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            width: 50px;
        }

        .sidebar-mini:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #c17b47;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .sidebar-mini.sidebar-open {
            left: 271px;
        }

        .mini-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .mini-icon:hover {
            transform: scale(1.1);
        }

        .mini-settings {
            background: #f8f8f8;
            color: #666;
            border: 1px solid #e5e5e5;
            font-size: 0.7rem;
        }

        .mini-settings:hover {
            background: #f0f0f0;
            color: #c17b47;
        }

        .mini-new-chat {
            background: #c17b47;
            color: white;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .mini-new-chat:hover {
            background: #a66939;
        }

        .mini-profile {
            background: #e5e5e5;
            color: #666;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .mini-profile:hover {
            background: #d5d5d5;
        }

        .mini-expand {
            background: transparent;
            color: #666;
            font-size: 0.8rem;
            border: none;
            margin-top: 0.25rem;
        }

        .mini-expand:hover {
            color: #c17b47;
        }

        /* Welcome Screen */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            text-align: center;
        }

        .welcome-header {
            margin-bottom: 3rem;
        }

        .omnix-icon {
            font-size: 3rem;
            margin-bottom: 1.5rem;
            color: #c17b47;
        }

        .welcome-title {
            font-size: 1.8rem;
            font-weight: 400;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            color: #666;
            font-weight: 300;
        }

        /* Input Container */
        .welcome-input-container {
            width: 100%;
            max-width: 600px;
            margin: 2rem 0;
        }

        .input-wrapper {
            position: relative;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            transition: all 0.2s ease;
        }

        .input-wrapper:hover {
            border-color: #c17b47;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .input-wrapper:focus-within {
            border-color: #c17b47;
            box-shadow: 0 0 0 3px rgba(193, 123, 71, 0.1);
        }

        #welcome-input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 1rem;
            line-height: 1.5;
            resize: none;
            font-family: inherit;
            background: transparent;
            min-height: 60px;
            padding: 8px 12px;
            margin-bottom: 45px;
            vertical-align: top;
            text-align: left;
            display: block;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #welcome-input::placeholder {
            color: #999;
        }

        .welcome-left-controls {
            position: absolute;
            left: 8px;
            bottom: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .welcome-right-controls {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .welcome-control-btn {
            background: rgba(248, 248, 248, 0.95);
            border: 1px solid rgba(229, 229, 229, 0.8);
            border-radius: 8px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
            font-size: 0.95rem;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
        }

        .welcome-control-btn:hover {
            background: rgba(240, 240, 240, 0.98);
            border-color: rgba(193, 123, 71, 0.6);
            color: #c17b47;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .welcome-control-btn i {
            transition: transform 0.2s ease;
        }


        .send-button {
            background: #c17b47;
            color: white;
            border: 1px solid #c17b47;
        }

        .send-button:hover {
            background: #a66939;
        }

        .send-button:disabled {
            background: #ddd;
            cursor: not-allowed;
        }

        /* Mode Buttons */
        .mode-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 0.75rem 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
            text-decoration: none;
            min-width: 100px;
        }

        .mode-btn:hover {
            border-color: #c17b47;
            background: #fefcfa;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .mode-btn i {
            font-size: 1rem;
            color: #c17b47;
        }

        /* Chat Interface */
        .chat-interface {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        .chat-interface.active {
            display: flex;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem 0;
            padding-bottom: 8rem;
            width: 100%;
            margin: 0;
            max-width: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Custom scrollbar positioned at screen edge */
        .chat-messages {
            scrollbar-width: thin;
            scrollbar-color: rgba(193, 123, 71, 0.3) transparent;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(193, 123, 71, 0.3);
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(193, 123, 71, 0.5);
            background-clip: content-box;
        }

        /* Force scrollbar to screen edge by removing margin/padding on right */
        .chat-interface {
            padding-right: 0;
            margin-right: 0;
        }

        body {
            padding-right: 0;
            margin-right: 0;
        }

        /* Messages */
        .message {
            margin-bottom: 1.5rem;
            max-width: 700px;
            width: 100%;
            padding: 0 2rem;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .message-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .user-avatar {
            background: #e5e5e5;
            color: #666;
        }

        .ai-avatar {
            background: #c17b47;
            color: white;
        }

        .message-role {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
        }

        .message-content {
            font-size: 1rem;
            line-height: 1.7;
            color: #1a1a1a;
            margin-left: 36px;
        }

        .message-content pre {
            background: #f8f8f8;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .message-content code {
            background: #f8f8f8;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        /* Input Area - Floating and Transparent */
        .chat-input-area {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            border: none;
            padding: 0;
            z-index: 1000;
            width: 700px;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .chat-input-wrapper {
            position: relative;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(229, 229, 229, 0.3);
            border-radius: 16px;
            padding: 1rem;
            transition: all 0.2s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .chat-input-wrapper:focus-within {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(193, 123, 71, 0.5);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15), 0 0 0 3px rgba(193, 123, 71, 0.1);
        }

        #chat-input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 1rem;
            line-height: 1.5;
            resize: none;
            font-family: inherit;
            background: transparent;
            min-height: 60px;
            max-height: 300px;
            padding: 8px 12px;
            margin-bottom: 45px;
            vertical-align: top;
            text-align: left;
            display: block;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #chat-input::placeholder {
            color: #999;
        }

        .input-left-controls {
            position: absolute;
            left: 8px;
            bottom: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-right-controls {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-control-btn {
            background: #f8f8f8;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
            font-size: 0.9rem;
        }

        .input-control-btn i {
            transition: transform 0.2s ease;
        }


        .input-control-btn:hover {
            background: #f0f0f0;
            border-color: #c17b47;
            color: #c17b47;
        }

        .chat-send-button {
            background: #c17b47;
            color: white;
            border: 1px solid #c17b47;
        }

        .chat-send-button:hover {
            background: #a66939;
            border-color: #a66939;
        }

        .chat-send-button:disabled {
            background: #ddd;
            border-color: #ddd;
            cursor: not-allowed;
        }

        /* Plus Button Menu */
        .plus-menu {
            position: absolute;
            bottom: 45px;
            left: 8px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 0.5rem;
            display: none;
            flex-direction: column;
            gap: 0.25rem;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            min-width: 180px;
        }

        .plus-menu.show {
            display: flex;
        }

        .plus-menu-item {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            color: #1a1a1a;
        }

        .plus-menu-item:hover {
            background: #f8f8f8;
        }

        .plus-menu-item i {
            color: #c17b47;
            font-size: 1rem;
            width: 16px;
        }

        /* Recording Panel */
        .recording-panel {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 1rem;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            display: none;
            align-items: center;
            gap: 1rem;
        }

        .recording-panel.show {
            display: flex;
        }

        .recording-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .record-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
        }

        .record-btn:hover {
            background: #dc2626;
        }

        .record-btn.recording {
            animation: pulse 2s infinite;
        }

        .stop-record-btn {
            background: #666;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stop-record-btn:hover {
            background: #555;
        }

        .recording-status {
            color: #666;
            font-size: 0.9rem;
        }

        /* Audio Visualizer */
        .audio-visualizer {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 30px;
            min-width: 100px;
        }

        .audio-bar {
            width: 3px;
            background: #c17b47;
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 4px;
        }

        /* File Upload */
        .file-input {
            display: none;
        }

        .uploaded-files {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .uploaded-file {
            background: rgba(193, 123, 71, 0.1);
            border: 1px solid rgba(193, 123, 71, 0.3);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #c17b47;
        }

        .uploaded-file .remove-file {
            cursor: pointer;
            color: #999;
            font-size: 0.7rem;
        }

        .uploaded-file .remove-file:hover {
            color: #ef4444;
        }

        /* MCP Connection Dialog */
        .mcp-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .mcp-dialog.show {
            display: flex;
        }

        .mcp-dialog-content {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .mcp-dialog-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
        }

        .mcp-dialog-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1a1a1a;
        }

        .mcp-dialog-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #666;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }

        .mcp-dialog-close:hover {
            background: #f0f0f0;
        }

        .mcp-connection-type {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .mcp-type-btn {
            flex: 1;
            padding: 1rem;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .mcp-type-btn.active {
            border-color: #c17b47;
            background: rgba(193, 123, 71, 0.1);
        }

        .mcp-type-btn:hover {
            border-color: #c17b47;
        }

        .mcp-input-group {
            margin-bottom: 1rem;
        }

        .mcp-input-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .mcp-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .mcp-input:focus {
            outline: none;
            border-color: #c17b47;
            box-shadow: 0 0 0 3px rgba(193, 123, 71, 0.1);
        }

        .mcp-textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }

        .mcp-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .mcp-btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
        }

        .mcp-btn-cancel {
            background: white;
            color: #666;
        }

        .mcp-btn-cancel:hover {
            background: #f8f8f8;
        }

        .mcp-btn-connect {
            background: #c17b47;
            color: white;
            border-color: #c17b47;
        }

        .mcp-btn-connect:hover {
            background: #a66939;
        }

        /* Loading indicator */
        .loading-message {
            display: none;
            margin-bottom: 1.5rem;
        }

        .loading-dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 36px;
        }

        .loading-dots span {
            width: 6px;
            height: 6px;
            background: #c17b47;
            border-radius: 50%;
            animation: loadingDots 1.5s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes loadingDots {
            0%, 80%, 100% { 
                opacity: 0.3; 
                transform: scale(0.8); 
            }
            40% { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .welcome-screen {
                padding: 1rem;
            }
            
            .welcome-title {
                font-size: 1.5rem;
            }
            
            .chat-messages {
                padding: 1rem 2% 8rem 2%;
            }
            
            .chat-header {
                padding: 1rem;
            }
            
            .chat-input-area {
                left: 50%;
                transform: translateX(-50%);
                width: 96%;
                max-width: 96%;
                bottom: 1rem;
            }
            
            .mode-buttons {
                gap: 0.5rem;
            }
            
            .mode-btn {
                min-width: auto;
                padding: 0.5rem 1rem;
            }
        }

        /* New Styles for Slider Popup */
        .slider-btn {
            background: #f8f8f8;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
            font-size: 0.9rem;
        }

        .slider-btn:hover {
            background: #f0f0f0;
            border-color: #c17b47;
            color: #c17b47;
        }

        .slider-popup {
            position: absolute;
            bottom: 45px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 320px;
            max-width: 90vw;
            max-height: 350px;
            overflow-y: auto;
            z-index: 1001;
        }

        .slider-popup.show {
            display: flex;
        }

        .slider-popup::-webkit-scrollbar {
            width: 6px;
        }

        .slider-popup::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .slider-popup::-webkit-scrollbar-thumb {
            background: #c17b47;
            border-radius: 3px;
        }

        .slider-popup::-webkit-scrollbar-thumb:hover {
            background: #a86a3a;
        }

        .slider-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .slider-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }

        .slider-dropdown {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 0.9rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider-dropdown:focus {
            outline: none;
            border-color: #c17b47;
            box-shadow: 0 0 0 3px rgba(193, 123, 71, 0.1);
        }

        .slider-tools-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .slider-tool-item {
            padding: 0.5rem;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .slider-tool-item:hover {
            background: #f8f8f8;
            border-color: #c17b47;
            color: #c17b47;
        }

        .slider-tool-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .slider-tool-group-title {
            font-size: 0.8rem;
            font-weight: 500;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .slider-add-btn {
            background: #c17b47;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider-add-btn:hover {
            background: #a66939;
        }

        .hidden {
            display: none !important;
        }

        /* New Enhanced Slider Popup Styles */
        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: white;
            transition: all 0.2s ease;
        }

        .toggle-item:hover {
            background: #f8f8f8;
            border-color: #c17b47;
        }

        .toggle-item-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #c17b47;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .dropdown-section {
            position: relative;
            margin-bottom: 1rem;
        }

        .dropdown-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dropdown-header:hover {
            background: #f8f8f8;
            border-color: #c17b47;
        }

        .dropdown-header-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dropdown-icon {
            color: #c17b47;
        }

        .dropdown-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .dropdown-arrow {
            transition: transform 0.2s ease;
            color: #666;
        }

        .dropdown-arrow.open {
            transform: rotate(180deg);
        }

        .dropdown-content {
            display: none;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 4px;
            overflow: visible;
        }

        .dropdown-content.show {
            display: block;
        }


        .dropdown-option {
            padding: 0.75rem;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .dropdown-option:hover {
            background: #f8f8f8;
        }

        .dropdown-option.selected {
            background: #c17b47;
            color: white;
        }

        .tools-dropdown-content {
            padding: 0.75rem;
        }

        .tools-section {
            margin-bottom: 1rem;
        }

        .tools-section:last-child {
            margin-bottom: 0;
        }

        .tools-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tools-add-btn {
            width: 100%;
            padding: 0.75rem;
            background: #c17b47;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 0.5rem;
        }

        .tools-add-btn:hover {
            background: #a66939;
        }

        .tools-available-btn {
            width: 100%;
            padding: 0.75rem;
            background: #f8f8f8;
            color: #666;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tools-available-btn:hover {
            background: #f0f0f0;
            border-color: #c17b47;
            color: #c17b47;
        }

        .separator {
            height: 1px;
            background: #e5e5e5;
            margin: 0.75rem 0;
        }

        /* Live Conversation Overlay Styles - Perplexity Style */
        .live-conversation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #fefcfa;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            padding: 2rem;
        }

        .live-conversation-overlay.show {
            display: flex;
            opacity: 1;
        }

        .live-conversation-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            width: 100%;
            height: 100%;
            max-width: 600px;
        }

        .live-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e5e5;
            border-radius: 50%;
            color: #666;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .live-close-btn:hover {
            border-color: #c17b47;
            color: #c17b47;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .perplexity-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .sources-btn {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 20px;
            padding: 0.5rem 1rem;
            color: #c17b47;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .sources-btn:hover {
            background: #f8f8f8;
            border-color: #c17b47;
        }

        .voice-sphere-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            flex: 1;
            justify-content: center;
        }

        .voice-sphere {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
            cursor: pointer;
            transition: all 0.3s ease;
            background: transparent;
        }

        .voice-sphere:hover {
            transform: scale(1.02);
        }

        .shifting-dots {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .voice-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #c17b47;
            border-radius: 50%;
            opacity: 0.7;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
            will-change: transform, opacity, background-color;
        }

        .voice-dot.scattered {
            animation: scatter 0.6s ease-out;
        }

        .voice-dot.active {
            background: #64C8FF;
            opacity: 1;
        }

        .voice-dot.ai-speaking {
            background: #FF9664;
            opacity: 1;
        }

        @keyframes scatter {
            0% {
                transform: translate(0, 0) scale(1);
            }
            50% {
                transform: translate(var(--scatter-x), var(--scatter-y)) scale(1.5);
                opacity: 1;
            }
            100% {
                transform: translate(0, 0) scale(1);
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0);
            }
            33% {
                transform: translate(2px, -2px);
            }
            66% {
                transform: translate(-2px, 1px);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(0.95);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        @keyframes ripple {
            0% {
                transform: scale(1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1.8);
                opacity: 0;
            }
        }

        .live-transcription {
            background: transparent;
            border-radius: 0;
            padding: 0;
            margin: 1rem 0;
            box-shadow: none;
            border: none;
            min-height: 60px;
            width: 100%;
            max-width: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .transcription-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.7);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
        }

        .transcription-text {
            font-size: 0.9rem;
            color: #1a1a1a;
            line-height: 1.5;
            min-height: 80px;
            background: rgba(255, 255, 255, 0.7);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            font-weight: 500;
            text-align: center;
        }

        .conversation-status {
            text-align: center;
            color: #1a1a1a;
            margin-top: 1rem;
        }

        /* Live Controls Styles */
        .live-controls {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .live-mic-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid #e0e0e0;
            border-radius: 50%;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .live-mic-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .live-mic-btn:active {
            transform: scale(0.98);
        }

        .live-mic-btn.recording {
            background: #ef4444;
            color: white;
            border-color: #dc2626;
            animation: pulse 1.5s infinite;
        }

        .live-mic-btn.listening {
            background: #c17b47;
            color: white;
            border-color: #a66838;
            animation: pulse 2s infinite;
        }

        .live-mic-btn i {
            font-size: 2rem;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(193, 123, 71, 0.7);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(193, 123, 71, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(193, 123, 71, 0);
            }
        }

        .live-text-input-container {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 400px;
        }

        .live-text-input-container input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }

        .live-text-input-container button {
            padding: 0.75rem 1rem;
            background: #c17b47;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .live-text-input-container button:hover {
            background: #a66838;
        }

        .status-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #c17b47;
        }

        .status-subtitle {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.5;
        }

        .live-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            margin-top: 1rem;
        }

        .mic-button {
            width: 80px;
            height: 80px;
            background: #c17b47;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(193, 123, 71, 0.3);
            position: relative;
        }

        .mic-button:hover {
            background: #a66939;
            transform: scale(1.05);
        }

        .mic-button:active {
            transform: scale(0.95);
        }

        .mic-button.recording {
            background: #e44;
            animation: recordingPulse 1s infinite;
        }

        .mic-button.muted {
            background: #666;
        }

        @keyframes recordingPulse {
            0%, 100% { box-shadow: 0 4px 16px rgba(238, 68, 68, 0.3); }
            50% { box-shadow: 0 4px 24px rgba(238, 68, 68, 0.6); }
        }

        .hands-free-toggle {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 20px;
            padding: 0.5rem 1rem;
            color: #666;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hands-free-toggle.active {
            background: #c17b47;
            color: white;
            border-color: #c17b47;
        }

        /* Responsive design for live conversation */
        @media (max-width: 768px) {
            .voice-sphere {
                width: 250px;
                height: 250px;
            }
            
            .live-conversation-container {
                gap: 1.5rem;
                padding: 1rem;
            }
            
            .live-transcription {
                padding: 1rem;
                min-height: 100px;
            }
            
            .mic-button {
                width: 70px;
                height: 70px;
                font-size: 1.8rem;
            }
            
            .status-text {
                font-size: 1.1rem;
            }
            
            .perplexity-header {
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">
                <i class="fas fa-comments"></i>
                Chat History
            </div>
            <button class="sidebar-close" id="sidebar-close">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <button class="new-chat-btn" id="new-chat-btn">
            <i class="fas fa-plus"></i>
            New Chat
        </button>
        
        <div class="chat-history-section">
            <div class="chat-history-title">Recent Chats</div>
            <div id="chat-history-list">
                <!-- Recent chats will be populated here -->
            </div>
        </div>
    </div>

    <!-- Sidebar Mini Version -->
    <div class="sidebar-mini" id="sidebar-mini">
        <div class="mini-icon mini-settings" id="mini-settings" title="Settings">
            <i class="fas fa-cog"></i>
        </div>
        <div class="mini-icon mini-new-chat" id="mini-new-chat" title="New Chat">
            <i class="fas fa-plus"></i>
        </div>
        <div class="mini-icon mini-profile" id="mini-profile" title="Profile">
            <i class="fas fa-user"></i>
        </div>
        <button class="mini-expand" id="mini-expand" title="Open Sidebar">
            <i class="fas fa-chevron-right"></i>
        </button>
    </div>

    <!-- Main Content -->
    <div class="main-content" id="main-content">
        <!-- Welcome Screen -->
        <div class="welcome-screen" id="welcome-screen">
        <div class="welcome-header">
            <div class="omnix-icon">⚡</div>
            <h1 class="welcome-title">How can Omnix AI help you today?</h1>
        </div>

        <div class="welcome-input-container">
            <div class="input-wrapper">
                <!-- Uploaded Files Display -->
                <div class="uploaded-files" id="welcome-uploaded-files"></div>
                
                <!-- Text Input -->
                <textarea id="welcome-input" placeholder="Ask me anything or choose a mode below..." rows="1"></textarea>
                
                <!-- Left Controls (Plus, Mic, and Slider) -->
                <div class="welcome-left-controls">
                    <button class="welcome-control-btn" id="welcome-plus-btn" title="More options">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="welcome-control-btn" id="welcome-mic-btn" title="Voice input">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="welcome-control-btn slider-btn" id="welcome-slider-btn" title="Settings & Options">
                        <i class="fas fa-sliders-h"></i>
                    </button>
                </div>
                
                <!-- Right Controls (Send) -->
                <div class="welcome-right-controls">
                    <button class="welcome-control-btn send-button" id="welcome-send-button" title="Send message">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </div>

                <!-- Plus Menu for Welcome -->
                <div class="plus-menu" id="welcome-plus-menu" style="bottom: auto; top: 45px; left: 8px;">
                    <div class="plus-menu-item" id="welcome-upload-files">
                        <i class="fas fa-paperclip"></i>
                        <span>Upload Files</span>
                    </div>
                    <div class="plus-menu-item" id="welcome-upload-video">
                        <i class="fas fa-video"></i>
                        <span>Upload Video</span>
                    </div>
                    <div class="plus-menu-item" id="welcome-upload-codebase">
                        <i class="fas fa-code"></i>
                        <span>Upload Codebase</span>
                    </div>
                    <div class="plus-menu-item" id="welcome-take-camera">
                        <i class="fas fa-camera"></i>
                        <span>Take Using Camera</span>
                    </div>
                </div>

                <!-- Slider Popup for Welcome -->
                <div class="slider-popup" id="welcome-slider-popup">
                    <!-- Feature Toggles -->
                    <div class="toggle-item">
                        <span class="toggle-item-label">Web Search</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="welcome-web-search-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Researcher</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="welcome-researcher-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Extended Reasoning</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="welcome-extended-reasoning-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Sequential Thinking</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="welcome-sequential-thinking-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>

                    <div class="separator"></div>

                    <!-- Styles Dropdown -->
                    <div class="dropdown-section">
                        <div class="dropdown-header" onclick="toggleWelcomeStylesDropdown(event)">
                            <div class="dropdown-header-content">
                                <i class="fas fa-feather-alt dropdown-icon"></i>
                                <span class="dropdown-title">Styles</span>
                            </div>
                            <i class="fas fa-chevron-down dropdown-arrow" id="welcome-styles-arrow"></i>
                        </div>
                        <div class="dropdown-content" id="welcome-styles-dropdown">
                            <div class="dropdown-option" onclick="selectWelcomeStyle('auto')">Auto</div>
                            <div class="dropdown-option" onclick="selectWelcomeStyle('formal')">Formal</div>
                            <div class="dropdown-option" onclick="selectWelcomeStyle('explanatory')">Explanatory</div>
                            <div class="dropdown-option" onclick="selectWelcomeStyle('concise')">Concise</div>
                            <div class="dropdown-option" onclick="selectWelcomeStyle('friendly')">Friendly</div>
                            <div class="dropdown-option" onclick="selectWelcomeStyle('custom')">Custom</div>
                        </div>
                    </div>

                    <!-- Tools Dropdown -->
                    <div class="dropdown-section">
                        <div class="dropdown-header" onclick="toggleWelcomeToolsDropdown(event)">
                            <div class="dropdown-header-content">
                                <i class="fas fa-tools dropdown-icon"></i>
                                <span class="dropdown-title">Tools</span>
                            </div>
                            <i class="fas fa-chevron-down dropdown-arrow" id="welcome-tools-arrow"></i>
                        </div>
                        <div class="dropdown-content tools-dropdown-content" id="welcome-tools-dropdown">
                            <div class="tools-section">
                                <div class="tools-section-title">MCP</div>
                                <button class="tools-add-btn" onclick="showMcpDialog()">+ Add New MCP</button>
                                <button class="tools-available-btn" onclick="showAvailableMcpTools()">Available MCP <i class="fas fa-chevron-right" style="float: right; margin-top: 2px;"></i></button>
                            </div>
                            
                            <div class="separator"></div>
                            
                            <div class="tools-section">
                                <div class="tools-section-title">Connectors</div>
                                <button class="tools-add-btn" onclick="showConnectorDialog()">+ Add New Connectors</button>
                                <button class="tools-available-btn" onclick="showAvailableConnectors()">Available Connectors</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mode-buttons">
            <button class="mode-btn" data-mode="research" title="Search the web and get comprehensive research">
                <i class="fas fa-search"></i>
                <span>Research</span>
            </button>
            <button class="mode-btn" data-mode="complex" title="Complex tasks, coding, and problem solving">
                <i class="fas fa-code"></i>
                <span>Complex</span>
            </button>
            <button class="mode-btn" data-mode="browser" title="Interactive browser automation and web tasks">
                <i class="fas fa-globe"></i>
                <span>Browser</span>
            </button>
            <button class="mode-btn" data-mode="live" title="Live conversation - mindful AI companion">
                <i class="fas fa-broadcast-tower"></i>
                <span>Live</span>
            </button>
        </div>
    </div>

    <!-- Chat Interface -->
    <div class="chat-interface" id="chat-interface">
        <div class="chat-messages" id="chat-messages">
            <!-- Messages will be added here -->
        </div>

        <div class="loading-message" id="loading-message">
            <div class="loading-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>

        <div class="chat-input-area">
            <!-- Recording Panel -->
            <div class="recording-panel" id="recording-panel">
                <div class="recording-controls">
                    <button class="record-btn" id="record-btn">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="stop-record-btn" id="stop-record-btn" style="display: none;">
                        <i class="fas fa-stop"></i>
                    </button>
                </div>
                <div class="recording-status" id="recording-status">Ready to record</div>
                <div class="audio-visualizer" id="audio-visualizer">
                    <!-- Audio bars will be generated here -->
                </div>
            </div>

            <!-- Uploaded Files Display -->
            <div class="uploaded-files" id="uploaded-files"></div>

            <div class="chat-input-wrapper">
                <textarea id="chat-input" placeholder="Type your message..." rows="1"></textarea>
                
                <!-- Plus Menu -->
                <div class="plus-menu" id="plus-menu">
                    <div class="plus-menu-item" id="upload-files">
                        <i class="fas fa-paperclip"></i>
                        <span>Upload Files</span>
                    </div>
                    <div class="plus-menu-item" id="upload-video">
                        <i class="fas fa-video"></i>
                        <span>Upload Video</span>
                    </div>
                    <div class="plus-menu-item" id="upload-codebase">
                        <i class="fas fa-code"></i>
                        <span>Upload Codebase</span>
                    </div>
                    <div class="plus-menu-item" id="take-camera">
                        <i class="fas fa-camera"></i>
                        <span>Take Using Camera</span>
                    </div>
                </div>
                
                <!-- Left Controls (Plus, Mic, and Slider) -->
                <div class="input-left-controls">
                    <button class="input-control-btn" id="plus-btn" title="More options">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="input-control-btn" id="mic-btn" title="Voice input">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="input-control-btn slider-btn" id="slider-btn" title="Settings & Options">
                        <i class="fas fa-sliders-h"></i>
                    </button>
                </div>

                <!-- Right Controls (Send) -->
                <div class="input-right-controls">
                    <button class="input-control-btn chat-send-button" id="chat-send-button" title="Send message">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </div>

                <!-- Slider Popup -->
                <div class="slider-popup" id="slider-popup">
                    <!-- Feature Toggles -->
                    <div class="toggle-item">
                        <span class="toggle-item-label">Web Search</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="web-search-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Researcher</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="researcher-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Extended Reasoning</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="extended-reasoning-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-item">
                        <span class="toggle-item-label">Sequential Thinking</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="sequential-thinking-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>

                    <div class="separator"></div>

                    <!-- Styles Dropdown -->
                    <div class="dropdown-section">
                        <div class="dropdown-header" onclick="toggleStylesDropdown(event)">
                            <div class="dropdown-header-content">
                                <i class="fas fa-feather-alt dropdown-icon"></i>
                                <span class="dropdown-title">Styles</span>
                            </div>
                            <i class="fas fa-chevron-down dropdown-arrow" id="styles-arrow"></i>
                        </div>
                        <div class="dropdown-content" id="styles-dropdown">
                            <div class="dropdown-option" onclick="selectStyle('auto')">Auto</div>
                            <div class="dropdown-option" onclick="selectStyle('formal')">Formal</div>
                            <div class="dropdown-option" onclick="selectStyle('explanatory')">Explanatory</div>
                            <div class="dropdown-option" onclick="selectStyle('concise')">Concise</div>
                            <div class="dropdown-option" onclick="selectStyle('friendly')">Friendly</div>
                            <div class="dropdown-option" onclick="selectStyle('custom')">Custom</div>
                        </div>
                    </div>

                    <!-- Tools Dropdown -->
                    <div class="dropdown-section">
                        <div class="dropdown-header" onclick="toggleToolsDropdown(event)">
                            <div class="dropdown-header-content">
                                <i class="fas fa-tools dropdown-icon"></i>
                                <span class="dropdown-title">Tools</span>
                            </div>
                            <i class="fas fa-chevron-down dropdown-arrow" id="tools-arrow"></i>
                        </div>
                        <div class="dropdown-content tools-dropdown-content" id="tools-dropdown">
                            <div class="tools-section">
                                <div class="tools-section-title">MCP</div>
                                <button class="tools-add-btn" onclick="showMcpDialog()">+ Add New MCP</button>
                                <button class="tools-available-btn" onclick="showAvailableMcpTools()">Available MCP <i class="fas fa-chevron-right" style="float: right; margin-top: 2px;"></i></button>
                            </div>
                            
                            <div class="separator"></div>
                            
                            <div class="tools-section">
                                <div class="tools-section-title">Connectors</div>
                                <button class="tools-add-btn" onclick="showConnectorDialog()">+ Add New Connectors</button>
                                <button class="tools-available-btn" onclick="showAvailableConnectors()">Available Connectors</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hidden File Input -->
            <input type="file" class="file-input" id="file-input" multiple accept="*/*">
            
            <!-- Hidden Welcome File Input -->
            <input type="file" class="file-input" id="welcome-file-input" multiple accept="*/*">
        </div>
    </div>
    </div>

    <!-- MCP Connection Dialog -->
    <div class="mcp-dialog" id="mcp-dialog">
        <div class="mcp-dialog-content">
            <div class="mcp-dialog-header">
                <div class="mcp-dialog-title">MCP Connection</div>
                <button class="mcp-dialog-close" id="mcp-dialog-close">&times;</button>
            </div>
            
            <div class="mcp-connection-type">
                <button class="mcp-type-btn active" id="mcp-type-url">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">URL Connection</div>
                    <div style="font-size: 0.9rem; color: #666;">Connect via WebSocket URL</div>
                </button>
                <button class="mcp-type-btn" id="mcp-type-json">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">JSON Config</div>
                    <div style="font-size: 0.9rem; color: #666;">Provide JSON configuration</div>
                </button>
            </div>
            
            <div id="mcp-url-form">
                <div class="mcp-input-group">
                    <label class="mcp-input-label" for="mcp-url-input">Server URL</label>
                    <input type="text" class="mcp-input" id="mcp-url-input" placeholder="ws://localhost:8080" />
                </div>
                <div class="mcp-input-group">
                    <label class="mcp-input-label" for="mcp-name-input">Connection Name</label>
                    <input type="text" class="mcp-input" id="mcp-name-input" placeholder="My MCP Server" />
                </div>
            </div>
            
            <div id="mcp-json-form" style="display: none;">
                <div class="mcp-input-group">
                    <label class="mcp-input-label" for="mcp-json-input">JSON Configuration</label>
                    <textarea class="mcp-input mcp-textarea" id="mcp-json-input" placeholder='{"url": "ws://localhost:8080", "name": "My Server", "auth": {"token": "..."}}'></textarea>
                </div>
            </div>
            
            <div class="mcp-dialog-actions">
                <button class="mcp-btn mcp-btn-cancel" id="mcp-cancel-btn">Cancel</button>
                <button class="mcp-btn mcp-btn-connect" id="mcp-connect-btn">Connect</button>
            </div>
        </div>
    </div>

    <!-- Live Conversation Overlay - Perplexity Style -->
    <div class="live-conversation-overlay" id="live-conversation-overlay">
        <div class="live-conversation-container">
            <!-- Close button -->
            <button class="live-close-btn" id="live-close-btn" title="Close live conversation">
                <i class="fas fa-times"></i>
            </button>
            
            <!-- Header with Sources -->
            <div class="perplexity-header">
                <button class="sources-btn" id="sources-btn">
                    <i class="fas fa-external-link-alt"></i> Sources
                </button>
            </div>
            
            <!-- Voice Sphere -->
            <div class="voice-sphere-container">
                <div class="voice-sphere" id="voice-sphere">
                    <div class="shifting-dots" id="shifting-dots"></div>
                </div>
                
                <!-- Live Transcription -->
                <div class="live-transcription" id="live-transcription">
                    <div class="transcription-text" id="transcription-text">Start speaking to see your words appear here...</div>
                </div>
                
                <!-- Live Controls - Mic Only -->
                <div class="live-controls">
                    <button class="live-mic-btn" id="live-mic-btn" title="Push to Talk">
                        <i class="fas fa-microphone"></i>
                    </button>
                </div>
                
                <!-- Text Input (hidden by default) -->
                <div class="live-text-input-container" id="live-text-input-container" style="display: none;">
                    <input type="text" id="live-text-input" placeholder="Type your message..." />
                    <button id="live-send-text-confirm"><i class="fas fa-paper-plane"></i></button>
                </div>
                
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentMode = 'chat';
        let isProcessing = false;
        let currentChatId = null;
        let chatHistory = [];
        let uploadedFiles = [];
        let isRecording = false;
        let mediaRecorder = null;
        let audioStream = null;
        let recognition = null;
        let sliderSettings = {
            mode: 'chat',
            style: 'auto',
            tools: {
                extendedReasoning: false,
                sequentialThinking: false,
                codeExecutor: false
            }
        };

        // Live conversation state
        let isLiveConversationActive = false;
        let isLiveRecording = false;
        let isListeningForSilence = false;
        let silenceTimer = null;
        let audioProcessor = null;
        let liveAudioContext = null;
        let liveAnalyser = null;
        let liveMediaStream = null;
        let audioBuffer = [];
        let particleSystem = null;

        // DOM elements
        const welcomeScreen = document.getElementById('welcome-screen');
        const chatInterface = document.getElementById('chat-interface');
        const welcomeInput = document.getElementById('welcome-input');
        const welcomeSendButton = document.getElementById('welcome-send-button');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');
        const loadingMessage = document.getElementById('loading-message');
        
        // Sidebar elements
        const sidebar = document.getElementById('sidebar');
        const sidebarMini = document.getElementById('sidebar-mini');
        const sidebarClose = document.getElementById('sidebar-close');
        const newChatBtn = document.getElementById('new-chat-btn');
        const miniNewChat = document.getElementById('mini-new-chat');
        const miniExpand = document.getElementById('mini-expand');
        const miniSettings = document.getElementById('mini-settings');
        const miniProfile = document.getElementById('mini-profile');
        const chatHistoryList = document.getElementById('chat-history-list');
        const mainContent = document.getElementById('main-content');
        
        // New input elements
        const plusBtn = document.getElementById('plus-btn');
        const plusMenu = document.getElementById('plus-menu');
        const micBtn = document.getElementById('mic-btn');
        const fileInput = document.getElementById('file-input');
        const uploadFilesBtn = document.getElementById('upload-files');
        const uploadVideoBtn = document.getElementById('upload-video');
        const uploadCodebaseBtn = document.getElementById('upload-codebase');
        const takeCameraBtn = document.getElementById('take-camera');
        const addMcpBtn = document.getElementById('add-mcp');
        const uploadedFilesDiv = document.getElementById('uploaded-files');
        const recordingPanel = document.getElementById('recording-panel');
        const recordBtn = document.getElementById('record-btn');
        const stopRecordBtn = document.getElementById('stop-record-btn');
        const recordingStatus = document.getElementById('recording-status');
        const audioVisualizer = document.getElementById('audio-visualizer');
        
        // Slider elements
        const sliderBtn = document.getElementById('slider-btn');
        const sliderPopup = document.getElementById('slider-popup');
        const welcomeSliderBtn = document.getElementById('welcome-slider-btn');
        const welcomeSliderPopup = document.getElementById('welcome-slider-popup');
        
        // Welcome screen input elements
        const welcomePlusBtn = document.getElementById('welcome-plus-btn');
        const welcomePlusMenu = document.getElementById('welcome-plus-menu');
        const welcomeMicBtn = document.getElementById('welcome-mic-btn');
        const welcomeFileInput = document.getElementById('welcome-file-input');
        const welcomeUploadFilesBtn = document.getElementById('welcome-upload-files');
        const welcomeUploadVideoBtn = document.getElementById('welcome-upload-video');
        const welcomeUploadCodebaseBtn = document.getElementById('welcome-upload-codebase');
        const welcomeTakeCameraBtn = document.getElementById('welcome-take-camera');
        const welcomeAddMcpBtn = document.getElementById('welcome-add-mcp');
        const welcomeUploadedFilesDiv = document.getElementById('welcome-uploaded-files');
        
        // MCP Dialog elements
        const mcpDialog = document.getElementById('mcp-dialog');
        const mcpDialogClose = document.getElementById('mcp-dialog-close');
        const mcpTypeUrl = document.getElementById('mcp-type-url');
        const mcpTypeJson = document.getElementById('mcp-type-json');
        const mcpUrlForm = document.getElementById('mcp-url-form');
        const mcpJsonForm = document.getElementById('mcp-json-form');
        const mcpUrlInput = document.getElementById('mcp-url-input');
        const mcpNameInput = document.getElementById('mcp-name-input');
        const mcpJsonInput = document.getElementById('mcp-json-input');
        const mcpCancelBtn = document.getElementById('mcp-cancel-btn');
        const mcpConnectBtn = document.getElementById('mcp-connect-btn');

        // Live conversation elements
        const liveConversationOverlay = document.getElementById('live-conversation-overlay');
        const liveCloseBtn = document.getElementById('live-close-btn');
        const liveMicBtn = document.getElementById('live-mic-btn');
        const liveTextInputContainer = document.getElementById('live-text-input-container');
        const liveTextInput = document.getElementById('live-text-input');
        const liveSendTextConfirm = document.getElementById('live-send-text-confirm');
        const particleCanvas = document.getElementById('particle-canvas');
        const conversationStatus = document.getElementById('conversation-status');
        
        // Live conversation state
        let liveSessionId = null;
        let isLiveSessionActive = false;
        let isAudioMuted = false;
        let sessionStartTimeout = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
        });

        function setupEventListeners() {
            console.log('Setting up event listeners...');
            console.log('Elements found:', {
                plusBtn: !!plusBtn,
                micBtn: !!micBtn, 
                sliderBtn: !!sliderBtn,
                welcomePlusBtn: !!welcomePlusBtn,
                welcomeMicBtn: !!welcomeMicBtn,
                welcomeSliderBtn: !!welcomeSliderBtn
            });
            
            // Welcome screen events
            if (welcomeSendButton) {
                welcomeSendButton.addEventListener('click', handleWelcomeMessage);
            }
            if (welcomeInput) {
                welcomeInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleWelcomeMessage();
                    }
                });
            }

            // Auto-resize welcome textarea
            welcomeInput.addEventListener('input', () => {
                welcomeInput.style.height = 'auto';
                welcomeInput.style.height = Math.min(welcomeInput.scrollHeight, 120) + 'px';
            });

            // Mode button events
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const mode = e.currentTarget.dataset.mode;
                    selectMode(mode);
                });
            });

            if (chatInput) {
                chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleChatMessage();
                    }
                });
            }

            // Chat interface events
            if (chatSendButton) {
                chatSendButton.addEventListener('click', handleChatMessage);
            }

            // Auto-resize chat textarea
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 200) + 'px';
            });

            // Sidebar events
            miniExpand.addEventListener('click', openSidebar);
            sidebarClose.addEventListener('click', closeSidebar);
            newChatBtn.addEventListener('click', startNewChat);
            miniNewChat.addEventListener('click', startNewChat);
            
            // Also make the entire mini sidebar clickable to expand
            sidebarMini.addEventListener('click', (e) => {
                // Only open sidebar if clicking the container directly or the expand button
                if (e.target === sidebarMini || e.target === miniExpand || e.target.closest('#mini-expand')) {
                    openSidebar();
                }
            });
            
            // Placeholder event listeners for settings and profile (no functionality yet)
            miniSettings.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent sidebar from opening
                console.log('Settings clicked - functionality not implemented yet');
            });
            miniProfile.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent sidebar from opening
                console.log('Profile clicked - functionality not implemented yet');
            });
            miniNewChat.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent sidebar from opening
                startNewChat();
            });

            // Input controls events
            if (plusBtn) {
                console.log('Adding event listener to plusBtn');
                plusBtn.addEventListener('click', togglePlusMenu);
            } else {
                console.log('ERROR: plusBtn element not found!');
            }
            if (micBtn) {
                console.log('Adding event listener to micBtn');
                micBtn.addEventListener('click', startVoiceInput);
            } else {
                console.log('ERROR: micBtn element not found!');
            }
            if (uploadFilesBtn) {
                uploadFilesBtn.addEventListener('click', () => {
                    fileInput.click();
                    togglePlusMenu();
                });
            }
            if (uploadVideoBtn) {
                uploadVideoBtn.addEventListener('click', () => {
                    const videoInput = document.createElement('input');
                    videoInput.type = 'file';
                    videoInput.accept = 'video/*';
                    videoInput.multiple = true;
                    videoInput.onchange = handleFileUpload;
                    videoInput.click();
                    togglePlusMenu();
                });
            }
            if (uploadCodebaseBtn) {
                uploadCodebaseBtn.addEventListener('click', () => {
                    const codebaseInput = document.createElement('input');
                    codebaseInput.type = 'file';
                    codebaseInput.webkitdirectory = true;
                    codebaseInput.onchange = handleFileUpload;
                    codebaseInput.click();
                    togglePlusMenu();
                });
            }
            if (takeCameraBtn) {
                takeCameraBtn.addEventListener('click', () => {
                    // Camera functionality - placeholder for now
                    alert('Camera functionality coming soon!');
                    togglePlusMenu();
                });
            }
            if (addMcpBtn) {
                addMcpBtn.addEventListener('click', () => {
                    showMcpDialog();
                    togglePlusMenu();
                });
            }
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }

            // Recording events
            if (recordBtn) {
                recordBtn.addEventListener('click', startRecording);
            }
            if (stopRecordBtn) {
                stopRecordBtn.addEventListener('click', stopRecording);
            }

            // Close plus menu when clicking outside
            document.addEventListener('click', (e) => {
                if (plusBtn && plusMenu && !plusBtn.contains(e.target) && !plusMenu.contains(e.target)) {
                    plusMenu.classList.remove('show');
                }
            });

            // Initialize audio visualizer
            initializeAudioVisualizer();
            
            // Initialize speech recognition
            initializeSpeechRecognition();

            // Welcome screen events
            if (welcomePlusBtn) {
                welcomePlusBtn.addEventListener('click', toggleWelcomePlusMenu);
            }
            if (welcomeMicBtn) {
                welcomeMicBtn.addEventListener('click', startWelcomeVoiceInput);
            }
            if (welcomeUploadFilesBtn) {
                welcomeUploadFilesBtn.addEventListener('click', () => {
                // Redirect to chat area when upload button is pressed from welcome screen
                if (!chatInterface.classList.contains('active')) {
                    // Generate new chat ID if none exists
                    if (!currentChatId) {
                        currentChatId = generateChatId();
                    }
                    
                    // Switch to chat interface
                    currentMode = 'chat';
                    showChatInterface();
                    
                    // Show plus menu in chat area and trigger file upload
                    setTimeout(() => {
                        plusMenu.classList.add('show');
                        fileInput.click();
                    }, 100);
                } else {
                    welcomeFileInput.click();
                }
                toggleWelcomePlusMenu();
                });
            }
            if (welcomeUploadVideoBtn) {
                welcomeUploadVideoBtn.addEventListener('click', () => {
                if (!chatInterface.classList.contains('active')) {
                    if (!currentChatId) {
                        currentChatId = generateChatId();
                    }
                    currentMode = 'chat';
                    showChatInterface();
                    setTimeout(() => {
                        const videoInput = document.createElement('input');
                        videoInput.type = 'file';
                        videoInput.accept = 'video/*';
                        videoInput.multiple = true;
                        videoInput.onchange = handleFileUpload;
                        videoInput.click();
                    }, 100);
                } else {
                    const videoInput = document.createElement('input');
                    videoInput.type = 'file';
                    videoInput.accept = 'video/*';
                    videoInput.multiple = true;
                    videoInput.onchange = handleWelcomeFileUpload;
                    videoInput.click();
                }
                toggleWelcomePlusMenu();
                });
            }
            if (welcomeUploadCodebaseBtn) {
                welcomeUploadCodebaseBtn.addEventListener('click', () => {
                if (!chatInterface.classList.contains('active')) {
                    if (!currentChatId) {
                        currentChatId = generateChatId();
                    }
                    currentMode = 'chat';
                    showChatInterface();
                    setTimeout(() => {
                        const codebaseInput = document.createElement('input');
                        codebaseInput.type = 'file';
                        codebaseInput.webkitdirectory = true;
                        codebaseInput.onchange = handleFileUpload;
                        codebaseInput.click();
                    }, 100);
                } else {
                    const codebaseInput = document.createElement('input');
                    codebaseInput.type = 'file';
                    codebaseInput.webkitdirectory = true;
                    codebaseInput.onchange = handleWelcomeFileUpload;
                    codebaseInput.click();
                }
                toggleWelcomePlusMenu();
                });
            }
            if (welcomeTakeCameraBtn) {
                welcomeTakeCameraBtn.addEventListener('click', () => {
                alert('Camera functionality coming soon!');
                toggleWelcomePlusMenu();
                });
            }
            if (welcomeAddMcpBtn) {
                welcomeAddMcpBtn.addEventListener('click', () => {
                showMcpDialog();
                toggleWelcomePlusMenu();
                });
            }
            if (welcomeFileInput) {
                welcomeFileInput.addEventListener('change', handleWelcomeFileUpload);
            }

            // Slider popup events
            if (sliderBtn) {
                console.log('Adding event listener to sliderBtn');
                sliderBtn.addEventListener('click', toggleSliderPopup);
            } else {
                console.log('ERROR: sliderBtn element not found!');
            }
            if (welcomeSliderBtn) {
                console.log('Adding event listener to welcomeSliderBtn');
                welcomeSliderBtn.addEventListener('click', toggleWelcomeSliderPopup);
            } else {
                console.log('ERROR: welcomeSliderBtn element not found!');
            }

            // MCP Dialog events
            mcpDialogClose.addEventListener('click', closeMcpDialog);
            mcpCancelBtn.addEventListener('click', closeMcpDialog);
            mcpConnectBtn.addEventListener('click', handleMcpConnect);
            mcpTypeUrl.addEventListener('click', () => switchMcpType('url'));
            mcpTypeJson.addEventListener('click', () => switchMcpType('json'));
            
            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (welcomePlusBtn && welcomePlusMenu && !welcomePlusBtn.contains(e.target) && !welcomePlusMenu.contains(e.target)) {
                    welcomePlusMenu.classList.remove('show');
                }
                if (plusBtn && plusMenu && !plusBtn.contains(e.target) && !plusMenu.contains(e.target)) {
                    plusMenu.classList.remove('show');
                }
                if (sliderBtn && sliderPopup && !sliderBtn.contains(e.target) && !sliderPopup.contains(e.target)) {
                    sliderPopup.classList.remove('show');
                }
                if (welcomeSliderBtn && welcomeSliderPopup && !welcomeSliderBtn.contains(e.target) && !welcomeSliderPopup.contains(e.target)) {
                    welcomeSliderPopup.classList.remove('show');
                }
            });

            // Load chat history
            loadChatHistory();
        }

        function toggleSliderPopup() {
            console.log('toggleSliderPopup called');
            if (sliderPopup) {
                sliderPopup.classList.toggle('show');
                console.log('Slider popup toggled. Visible:', sliderPopup.classList.contains('show'));
            } else {
                console.log('ERROR: sliderPopup element not found!');
            }
        }

        function toggleWelcomeSliderPopup() {
            console.log('toggleWelcomeSliderPopup called');
            if (welcomeSliderPopup) {
                welcomeSliderPopup.classList.toggle('show');
                console.log('Welcome slider popup toggled. Visible:', welcomeSliderPopup.classList.contains('show'));
            } else {
                console.log('ERROR: welcomeSliderPopup element not found!');
            }
        }

        function showMcpDialog() {
            mcpDialog.classList.add('show');
            if (sliderPopup) sliderPopup.classList.remove('show');
            if (welcomeSliderPopup) welcomeSliderPopup.classList.remove('show');
        }

        function showConnectorDialog() {
            console.log('Connector dialog - coming soon');
            alert('Connector management feature coming soon!');
        }

        function showAvailableMcpTools() {
            console.log('Available MCP tools - coming soon');
            alert('MCP tools management feature coming soon!');
        }

        function showAvailableConnectors() {
            console.log('Available connectors - coming soon');
            alert('Connectors management feature coming soon!');
        }

        function toggleExtendedReasoning() {
            sliderSettings.tools.extendedReasoning = !sliderSettings.tools.extendedReasoning;
            console.log('Extended Reasoning:', sliderSettings.tools.extendedReasoning);
        }

        function toggleSequentialThinking() {
            sliderSettings.tools.sequentialThinking = !sliderSettings.tools.sequentialThinking;
            console.log('Sequential Thinking:', sliderSettings.tools.sequentialThinking);
        }

        function toggleCodeExecutor() {
            sliderSettings.tools.codeExecutor = !sliderSettings.tools.codeExecutor;
            console.log('Code Executor:', sliderSettings.tools.codeExecutor);
        }

        function selectMode(mode) {
            // Handle browser mode differently - redirect to interactive page
            if (mode === 'browser') {
                window.location.href = '/interactive';
                return;
            }
            
            // Handle live conversation mode
            if (mode === 'live') {
                startLiveConversation();
                return;
            }
            
            // Generate new chat ID if none exists
            if (!currentChatId) {
                currentChatId = generateChatId();
            }
            
            currentMode = mode;
            showChatInterface();
            
            const modeNames = {
                'chat': 'Chat',
                'research': 'Research',
                'complex': 'Complex Tasks'
            };
            
            // Update dropdown to match selected mode
            const modeSelect = document.getElementById('mode-select');
            const welcomeModeSelect = document.getElementById('welcome-mode-select');
            if (modeSelect) modeSelect.value = mode;
            if (welcomeModeSelect) welcomeModeSelect.value = mode;
            
            const placeholders = {
                'chat': 'How can I help you?',
                'research': 'What would you like me to research?',
                'complex': 'Describe your complex task or problem...'
            };
            
            chatInput.placeholder = placeholders[mode];
            
            // Add welcome message
            addMessage('ai', `${modeNames[mode]} mode activated. ${placeholders[mode]}`);
        }

        async function handleWelcomeMessage() {
            if (!welcomeInput) return;
            const message = welcomeInput.value.trim();
            if (!message || isProcessing) return;

            // Clear the input
            welcomeInput.value = '';
            welcomeInput.style.height = 'auto';

            // Generate new chat ID if none exists
            if (!currentChatId) {
                currentChatId = generateChatId();
            }

            // Default to chat mode
            currentMode = 'chat';
            showChatInterface();
            
            // Process the message
            await processMessage(message);
        }

        async function handleChatMessage() {
            const message = chatInput.value.trim();
            if (!message || isProcessing) return;
            
            chatInput.value = '';
            chatInput.style.height = 'auto';
            
            await processMessage(message);
        }

        async function processMessage(message) {
            if (isProcessing) return;
            
            isProcessing = true;
            
            // Add user message
            addMessage('user', message);
            
            // Show loading
            showLoading();
            
            try {
                let endpoint = '/chat';
                let body = { message: message };
                
                if (currentMode === 'research') {
                    endpoint = '/research';
                    body = { query: message };
                } else if (currentMode === 'complex') {
                    endpoint = '/complex_task';
                    body = { prompt: message };
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                hideLoading();
                
                if (currentMode === 'research' && data.sources) {
                    addResearchMessage(data.summary, data.sources);
                } else if (data.response) {
                    addMessage('ai', data.response);
                } else {
                    addMessage('ai', 'Sorry, I encountered an error processing your request.');
                }
                
            } catch (error) {
                hideLoading();
                addMessage('ai', `Connection error: ${error.message}`);
                console.error('Error:', error);
            }
            
            isProcessing = false;
        }

        function showChatInterface() {
            welcomeScreen.classList.add('hidden');
            chatInterface.classList.add('active');
            chatInput.focus();
        }

        function addMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            
            const avatar = document.createElement('div');
            avatar.className = `message-avatar ${role}-avatar`;
            avatar.textContent = role === 'user' ? 'U' : 'AI';
            
            const roleSpan = document.createElement('span');
            roleSpan.className = 'message-role';
            roleSpan.textContent = role === 'user' ? 'You' : 'Omnix AI';
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.appendChild(avatar);
            header.appendChild(roleSpan);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(header);
            messageDiv.appendChild(contentDiv);
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addResearchMessage(summary, sources) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar ai-avatar';
            avatar.textContent = 'AI';
            
            const roleSpan = document.createElement('span');
            roleSpan.className = 'message-role';
            roleSpan.textContent = 'Omnix AI';
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.appendChild(avatar);
            header.appendChild(roleSpan);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Add summary
            const summaryP = document.createElement('p');
            summaryP.textContent = summary;
            contentDiv.appendChild(summaryP);
            
            // Add sources
            if (sources && sources.length > 0) {
                const sourcesTitle = document.createElement('p');
                sourcesTitle.innerHTML = '<strong>Sources:</strong>';
                sourcesTitle.style.marginTop = '1rem';
                contentDiv.appendChild(sourcesTitle);
                
                sources.forEach(source => {
                    const sourceLink = document.createElement('a');
                    sourceLink.href = source.url;
                    sourceLink.target = '_blank';
                    sourceLink.textContent = source.title;
                    sourceLink.style.display = 'block';
                    sourceLink.style.color = '#c17b47';
                    sourceLink.style.textDecoration = 'underline';
                    sourceLink.style.marginBottom = '0.25rem';
                    contentDiv.appendChild(sourceLink);
                });
            }
            
            messageDiv.appendChild(header);
            messageDiv.appendChild(contentDiv);
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function showLoading() {
            loadingMessage.style.display = 'block';
            scrollToBottom();
        }

        function hideLoading() {
            loadingMessage.style.display = 'none';
        }

        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Sidebar functionality
        function openSidebar() {
            sidebar.classList.add('open');
            mainContent.classList.add('sidebar-open');
            sidebarMini.classList.add('sidebar-open');
        }

        function closeSidebar() {
            sidebar.classList.remove('open');
            mainContent.classList.remove('sidebar-open');
            sidebarMini.classList.remove('sidebar-open');
        }

        function startNewChat() {
            // Save current chat if exists
            if (currentChatId && chatMessages.children.length > 0) {
                saveChatToHistory();
            }

            // Reset interface
            currentChatId = generateChatId();
            currentMode = 'chat';
            chatMessages.innerHTML = '';
            
            // Show welcome screen
            chatInterface.classList.remove('active');
            welcomeScreen.classList.remove('hidden');
            
            welcomeInput.value = '';
            welcomeInput.focus();
            
            closeSidebar();
        }

        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function saveChatToHistory() {
            if (!currentChatId || chatMessages.children.length === 0) return;

            const firstMessage = chatMessages.querySelector('.message .message-content');
            const title = firstMessage ? 
                firstMessage.textContent.substring(0, 50) + (firstMessage.textContent.length > 50 ? '...' : '') :
                'New Chat';

            const chatData = {
                id: currentChatId,
                title: title,
                mode: currentMode,
                timestamp: new Date().toISOString(),
                messages: Array.from(chatMessages.children).map(msg => ({
                    role: msg.querySelector('.message-role')?.textContent || 'Unknown',
                    content: msg.querySelector('.message-content')?.textContent || ''
                }))
            };

            // Update existing chat or add new one
            const existingIndex = chatHistory.findIndex(chat => chat.id === currentChatId);
            if (existingIndex >= 0) {
                chatHistory[existingIndex] = chatData;
            } else {
                chatHistory.unshift(chatData);
            }

            // Keep only last 50 chats
            if (chatHistory.length > 50) {
                chatHistory = chatHistory.slice(0, 50);
            }

            localStorage.setItem('omnix_chat_history', JSON.stringify(chatHistory));
            renderChatHistory();
        }

        function loadChatHistory() {
            try {
                const saved = localStorage.getItem('omnix_chat_history');
                if (saved) {
                    chatHistory = JSON.parse(saved);
                    renderChatHistory();
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
                chatHistory = [];
            }
        }

        function renderChatHistory() {
            chatHistoryList.innerHTML = '';

            if (chatHistory.length === 0) {
                chatHistoryList.innerHTML = '<div style="padding: 1rem 0.5rem; color: #666; font-size: 0.8rem; text-align: center;">No recent chats</div>';
                return;
            }

            chatHistory.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = 'chat-item';
                if (chat.id === currentChatId) {
                    chatItem.classList.add('active');
                }

                const timeStr = new Date(chat.timestamp).toLocaleDateString();
                
                chatItem.innerHTML = `
                    <div class="chat-item-title">${chat.title}</div>
                    <div class="chat-item-time">${timeStr} • ${chat.mode}</div>
                `;

                chatItem.addEventListener('click', () => loadChat(chat));
                chatHistoryList.appendChild(chatItem);
            });
        }

        function loadChat(chat) {
            // Save current chat first
            if (currentChatId && currentChatId !== chat.id && chatMessages.children.length > 0) {
                saveChatToHistory();
            }

            currentChatId = chat.id;
            currentMode = chat.mode;
            
            // Clear and restore messages
            chatMessages.innerHTML = '';
            chat.messages.forEach(msg => {
                const role = msg.role.toLowerCase().includes('you') ? 'user' : 'ai';
                addMessage(role, msg.content);
            });

            // Show chat interface
            showChatInterface();
            
            closeSidebar();
            renderChatHistory(); // Update active state
        }

        // Plus Menu Functionality
        function togglePlusMenu() {
            console.log('togglePlusMenu called');
            if (plusMenu) {
                plusMenu.classList.toggle('show');
                console.log('Plus menu toggled. Visible:', plusMenu.classList.contains('show'));
            } else {
                console.log('ERROR: plusMenu element not found!');
            }
        }

        // File Upload Functionality
        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                uploadedFiles.push({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    file: file
                });
            });
            renderUploadedFiles();
            event.target.value = ''; // Clear the input
        }

        function renderUploadedFiles() {
            uploadedFilesDiv.innerHTML = '';
            uploadedFiles.forEach((fileData, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'uploaded-file';
                
                const icon = getFileIcon(fileData.type);
                fileDiv.innerHTML = `
                    <i class="${icon}"></i>
                    <span>${fileData.name}</span>
                    <span class="remove-file" onclick="removeFile(${index})">×</span>
                `;
                
                uploadedFilesDiv.appendChild(fileDiv);
            });
        }

        function getFileIcon(fileType) {
            if (fileType.startsWith('image/')) return 'fas fa-image';
            if (fileType.startsWith('video/')) return 'fas fa-video';
            if (fileType.startsWith('audio/')) return 'fas fa-music';
            if (fileType.includes('pdf')) return 'fas fa-file-pdf';
            if (fileType.includes('text') || fileType.includes('json') || fileType.includes('javascript') || fileType.includes('python')) return 'fas fa-file-code';
            if (fileType.includes('zip') || fileType.includes('tar')) return 'fas fa-file-archive';
            return 'fas fa-file';
        }

        function removeFile(index) {
            uploadedFiles.splice(index, 1);
            renderUploadedFiles();
        }

        // Welcome Screen Functionality
        function toggleWelcomePlusMenu() {
            console.log('toggleWelcomePlusMenu called');
            if (welcomePlusMenu) {
                welcomePlusMenu.classList.toggle('show');
                console.log('Welcome plus menu toggled. Visible:', welcomePlusMenu.classList.contains('show'));
            } else {
                console.log('ERROR: welcomePlusMenu element not found!');
            }
        }

        function handleWelcomeFileUpload(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                uploadedFiles.push({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    file: file
                });
            });
            renderWelcomeUploadedFiles();
            event.target.value = ''; // Clear the input
        }

        function renderWelcomeUploadedFiles() {
            welcomeUploadedFilesDiv.innerHTML = '';
            uploadedFiles.forEach((fileData, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'uploaded-file';
                
                const icon = getFileIcon(fileData.type);
                fileDiv.innerHTML = `
                    <i class="${icon}"></i>
                    <span>${fileData.name}</span>
                    <span class="remove-file" onclick="removeWelcomeFile(${index})">×</span>
                `;
                
                welcomeUploadedFilesDiv.appendChild(fileDiv);
            });
        }

        function removeWelcomeFile(index) {
            uploadedFiles.splice(index, 1);
            renderWelcomeUploadedFiles();
        }

        function startWelcomeVoiceInput() {
            // Redirect to chat area when mic button is pressed from welcome screen
            if (!chatInterface.classList.contains('active')) {
                // Generate new chat ID if none exists
                if (!currentChatId) {
                    currentChatId = generateChatId();
                }
                
                // Switch to chat interface
                currentMode = 'chat';
                showChatInterface();
            }
            
            // Start voice recording in chat area
            if (!isRecording) {
                recordingPanel.classList.add('show');
                startRecording();
            }
        }

        // MCP Connection Functionality
        function showMcpDialog() {
            mcpDialog.classList.add('show');
        }

        function closeMcpDialog() {
            mcpDialog.classList.remove('show');
            // Reset form
            mcpUrlInput.value = '';
            mcpNameInput.value = '';
            mcpJsonInput.value = '';
            switchMcpType('url');
        }

        function switchMcpType(type) {
            if (type === 'url') {
                mcpTypeUrl.classList.add('active');
                mcpTypeJson.classList.remove('active');
                mcpUrlForm.style.display = 'block';
                mcpJsonForm.style.display = 'none';
            } else {
                mcpTypeJson.classList.add('active');
                mcpTypeUrl.classList.remove('active');
                mcpUrlForm.style.display = 'none';
                mcpJsonForm.style.display = 'block';
            }
        }

        function handleMcpConnect() {
            const isUrlMode = mcpTypeUrl.classList.contains('active');
            let connectionData;

            if (isUrlMode) {
                const url = mcpUrlInput.value.trim();
                const name = mcpNameInput.value.trim() || 'MCP Server';
                
                if (!url) {
                    alert('Please enter a server URL');
                    return;
                }

                connectionData = { url, name, type: 'url' };
            } else {
                const jsonConfig = mcpJsonInput.value.trim();
                
                if (!jsonConfig) {
                    alert('Please enter JSON configuration');
                    return;
                }

                try {
                    connectionData = JSON.parse(jsonConfig);
                    connectionData.type = 'json';
                } catch (error) {
                    alert('Invalid JSON configuration: ' + error.message);
                    return;
                }
            }

            console.log('MCP connection requested:', connectionData);
            addMessage('system', `Attempting to connect to MCP server: ${connectionData.name || connectionData.url}`);
            
            // TODO: Implement actual MCP connection
            closeMcpDialog();
        }

        // Voice Input and Recording Functionality
        function startVoiceInput() {
            console.log('startVoiceInput called');
            if (!isRecording) {
                recordingPanel.classList.add('show');
                startRecording();
            } else {
                console.log('Already recording');
            }
        }

        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                recognition.onstart = () => {
                    recordingStatus.textContent = 'Listening...';
                };

                recognition.onresult = (event) => {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        transcript += event.results[i][0].transcript;
                    }
                    // Default to chat input, will be overridden by welcome voice input if needed
                    if (chatInterface.classList.contains('active')) {
                        chatInput.value = transcript;
                    } else {
                        welcomeInput.value = transcript;
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    recordingStatus.textContent = `Error: ${event.error}`;
                };

                recognition.onend = () => {
                    isRecording = false;
                    recordBtn.classList.remove('recording');
                    recordBtn.style.display = 'block';
                    stopRecordBtn.style.display = 'none';
                    recordingStatus.textContent = 'Ready to record';
                    recordingPanel.classList.remove('show');
                };
            } else {
                console.warn('Speech recognition not supported in this browser');
            }
        }

        async function startRecording() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                if (recognition) {
                    recognition.start();
                    isRecording = true;
                    recordBtn.classList.add('recording');
                    recordBtn.style.display = 'none';
                    stopRecordBtn.style.display = 'block';
                    recordingStatus.textContent = 'Recording... Speak now';
                    
                    // Start audio visualization
                    startAudioVisualization(audioStream);
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                recordingStatus.textContent = 'Microphone access denied';
            }
        }

        function stopRecording() {
            if (recognition) {
                recognition.stop();
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            stopAudioVisualization();
        }

        // Audio Visualization
        function initializeAudioVisualizer() {
            // Create audio bars
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '4px';
                audioVisualizer.appendChild(bar);
            }
        }

        function startAudioVisualization(stream) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            const microphone = audioContext.createMediaStreamSource(stream);
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            microphone.connect(analyser);
            analyser.fftSize = 256;

            const bars = audioVisualizer.querySelectorAll('.audio-bar');

            function animate() {
                if (!isRecording) return;
                
                analyser.getByteFrequencyData(dataArray);
                
                for (let i = 0; i < bars.length; i++) {
                    const value = dataArray[i * 4] || 0;
                    const height = Math.max(4, (value / 255) * 30);
                    bars[i].style.height = height + 'px';
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }

        function stopAudioVisualization() {
            const bars = audioVisualizer.querySelectorAll('.audio-bar');
            bars.forEach(bar => {
                bar.style.height = '4px';
            });
        }

        // Auto-save chat periodically
        setInterval(() => {
            if (currentChatId && chatMessages.children.length > 0) {
                saveChatToHistory();
            }
        }, 30000); // Save every 30 seconds

        // New Enhanced Slider Functions
        
        // Dropdown toggle functions for chat interface
        function toggleStylesDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('styles-dropdown');
            const arrow = document.getElementById('styles-arrow');
            dropdown.classList.toggle('show');
            arrow.classList.toggle('open');
        }

        function toggleToolsDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('tools-dropdown');
            const arrow = document.getElementById('tools-arrow');
            dropdown.classList.toggle('show');
            arrow.classList.toggle('open');
        }

        function selectStyle(style) {
            console.log('Style selected:', style);
            sliderSettings.style = style;
            // Close dropdown
            document.getElementById('styles-dropdown').classList.remove('show');
            document.getElementById('styles-arrow').classList.remove('open');
        }

        // Dropdown toggle functions for welcome interface
        function toggleWelcomeStylesDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('welcome-styles-dropdown');
            const arrow = document.getElementById('welcome-styles-arrow');
            dropdown.classList.toggle('show');
            arrow.classList.toggle('open');
        }

        function toggleWelcomeToolsDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('welcome-tools-dropdown');
            const arrow = document.getElementById('welcome-tools-arrow');
            dropdown.classList.toggle('show');
            arrow.classList.toggle('open');
        }

        function selectWelcomeStyle(style) {
            console.log('Welcome style selected:', style);
            sliderSettings.style = style;
            // Close dropdown
            document.getElementById('welcome-styles-dropdown').classList.remove('show');
            document.getElementById('welcome-styles-arrow').classList.remove('open');
        }

        // Updated connector and MCP functions
        function showConnectorDialog() {
            alert('Connector management feature coming soon!');
            // Close dropdowns
            const toolsDropdown = document.getElementById('tools-dropdown');
            const welcomeToolsDropdown = document.getElementById('welcome-tools-dropdown');
            if (toolsDropdown) {
                toolsDropdown.classList.remove('show');
                document.getElementById('tools-arrow').classList.remove('open');
            }
            if (welcomeToolsDropdown) {
                welcomeToolsDropdown.classList.remove('show');
                document.getElementById('welcome-tools-arrow').classList.remove('open');
            }
        }

        function showAvailableConnectors() {
            alert('Available connectors feature coming soon!');
            // Close dropdowns
            const toolsDropdown = document.getElementById('tools-dropdown');
            const welcomeToolsDropdown = document.getElementById('welcome-tools-dropdown');
            if (toolsDropdown) {
                toolsDropdown.classList.remove('show');
                document.getElementById('tools-arrow').classList.remove('open');
            }
            if (welcomeToolsDropdown) {
                welcomeToolsDropdown.classList.remove('show');
                document.getElementById('welcome-tools-arrow').classList.remove('open');
            }
        }

        // Updated MCP functions to work with new design
        function showAvailableMcpTools() {
            console.log('Available MCP tools - coming soon');
            alert('MCP tools management feature coming soon!');
            // Close dropdowns
            const toolsDropdown = document.getElementById('tools-dropdown');
            const welcomeToolsDropdown = document.getElementById('welcome-tools-dropdown');
            if (toolsDropdown) {
                toolsDropdown.classList.remove('show');
                document.getElementById('tools-arrow').classList.remove('open');
            }
            if (welcomeToolsDropdown) {
                welcomeToolsDropdown.classList.remove('show');
                document.getElementById('welcome-tools-arrow').classList.remove('open');
            }
        }

        // Toggle functionality for feature switches
        function setupToggleListeners() {
            // Web Search toggles
            const webSearchToggle = document.getElementById('web-search-toggle');
            const welcomeWebSearchToggle = document.getElementById('welcome-web-search-toggle');
            
            if (webSearchToggle) {
                webSearchToggle.addEventListener('change', function() {
                    sliderSettings.tools.webSearch = this.checked;
                    console.log('Web Search:', this.checked);
                });
            }
            
            if (welcomeWebSearchToggle) {
                welcomeWebSearchToggle.addEventListener('change', function() {
                    sliderSettings.tools.webSearch = this.checked;
                    console.log('Welcome Web Search:', this.checked);
                    // Sync with chat toggle
                    if (webSearchToggle) webSearchToggle.checked = this.checked;
                });
            }

            // Researcher toggles
            const researcherToggle = document.getElementById('researcher-toggle');
            const welcomeResearcherToggle = document.getElementById('welcome-researcher-toggle');
            
            if (researcherToggle) {
                researcherToggle.addEventListener('change', function() {
                    sliderSettings.tools.researcher = this.checked;
                    console.log('Researcher:', this.checked);
                });
            }
            
            if (welcomeResearcherToggle) {
                welcomeResearcherToggle.addEventListener('change', function() {
                    sliderSettings.tools.researcher = this.checked;
                    console.log('Welcome Researcher:', this.checked);
                    // Sync with chat toggle
                    if (researcherToggle) researcherToggle.checked = this.checked;
                });
            }

            // Extended Reasoning toggles
            const extendedReasoningToggle = document.getElementById('extended-reasoning-toggle');
            const welcomeExtendedReasoningToggle = document.getElementById('welcome-extended-reasoning-toggle');
            
            if (extendedReasoningToggle) {
                extendedReasoningToggle.addEventListener('change', function() {
                    sliderSettings.tools.extendedReasoning = this.checked;
                    console.log('Extended Reasoning:', this.checked);
                });
            }
            
            if (welcomeExtendedReasoningToggle) {
                welcomeExtendedReasoningToggle.addEventListener('change', function() {
                    sliderSettings.tools.extendedReasoning = this.checked;
                    console.log('Welcome Extended Reasoning:', this.checked);
                    // Sync with chat toggle
                    if (extendedReasoningToggle) extendedReasoningToggle.checked = this.checked;
                });
            }

            // Sequential Thinking toggles
            const sequentialThinkingToggle = document.getElementById('sequential-thinking-toggle');
            const welcomeSequentialThinkingToggle = document.getElementById('welcome-sequential-thinking-toggle');
            
            if (sequentialThinkingToggle) {
                sequentialThinkingToggle.addEventListener('change', function() {
                    sliderSettings.tools.sequentialThinking = this.checked;
                    console.log('Sequential Thinking:', this.checked);
                });
            }
            
            if (welcomeSequentialThinkingToggle) {
                welcomeSequentialThinkingToggle.addEventListener('change', function() {
                    sliderSettings.tools.sequentialThinking = this.checked;
                    console.log('Welcome Sequential Thinking:', this.checked);
                    // Sync with chat toggle
                    if (sequentialThinkingToggle) sequentialThinkingToggle.checked = this.checked;
                });
            }
        }

        // Initialize toggle listeners after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            setupToggleListeners();
        });

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if (welcomePlusBtn && welcomePlusMenu && !welcomePlusBtn.contains(e.target) && !welcomePlusMenu.contains(e.target)) {
                welcomePlusMenu.classList.remove('show');
            }
            if (plusBtn && plusMenu && !plusBtn.contains(e.target) && !plusMenu.contains(e.target)) {
                plusMenu.classList.remove('show');
            }
            if (sliderBtn && sliderPopup && !sliderBtn.contains(e.target) && !sliderPopup.contains(e.target)) {
                sliderPopup.classList.remove('show');
                // Also close dropdowns when slider popup closes
                document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
                document.querySelectorAll('.dropdown-arrow').forEach(arrow => {
                    arrow.classList.remove('open');
                });
            }
            if (welcomeSliderBtn && welcomeSliderPopup && !welcomeSliderBtn.contains(e.target) && !welcomeSliderPopup.contains(e.target)) {
                welcomeSliderPopup.classList.remove('show');
                // Also close dropdowns when slider popup closes
                document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
                document.querySelectorAll('.dropdown-arrow').forEach(arrow => {
                    arrow.classList.remove('open');
                });
            }
            
            // Close individual dropdowns when clicking outside them (but only if slider popup is still open)
            if ((sliderPopup && sliderPopup.classList.contains('show')) || 
                (welcomeSliderPopup && welcomeSliderPopup.classList.contains('show'))) {
                const dropdowns = document.querySelectorAll('.dropdown-section');
                dropdowns.forEach(section => {
                    if (!section.contains(e.target) && !e.target.closest('.dropdown-header')) {
                        const dropdown = section.querySelector('.dropdown-content');
                        const arrow = section.querySelector('.dropdown-arrow');
                        if (dropdown) dropdown.classList.remove('show');
                        if (arrow) arrow.classList.remove('open');
                    }
                });
            }
        });

        // Live Conversation Functions
        function startLiveConversation() {
            console.log('Starting live conversation...');
            isLiveConversationActive = true;
            liveConversationOverlay.classList.add('show');
            initializeVoiceSphere();
            initializeLiveAudio();
            setupLiveControls();
            updateConversationStatus('Ready', 'Click Start to begin your conversation');
            
            // Show start button, hide others initially
            // liveStartBtn removed - using mic button only
            if (liveStopBtn) liveStopBtn.style.display = 'none';
        }

        function closeLiveConversation() {
            console.log('Closing live conversation...');
            isLiveConversationActive = false;
            liveConversationOverlay.classList.remove('show');
            
            // Clean up audio resources
            if (liveMediaStream) {
                liveMediaStream.getTracks().forEach(track => track.stop());
                liveMediaStream = null;
            }
            
            if (liveAudioContext) {
                liveAudioContext.close();
                liveAudioContext = null;
            }
            
            // ElevenLabs uses SocketIO, no separate WebSocket to close
            
            if (voiceSphereSystem) {
                voiceSphereSystem.stop();
                voiceSphereSystem = null;
            }
        }

        function setupLiveControls() {
            // Close button
            const liveCloseBtn = document.getElementById('live-close-btn');
            if (liveCloseBtn) {
                liveCloseBtn.addEventListener('click', closeLiveConversation);
            }
            
            // Microphone button - click to start/stop
            if (liveMicBtn) {
                liveMicBtn.addEventListener('click', toggleLiveRecording);
            }
            
            // Hands-free toggle
            const handsFreeToggle = document.getElementById('hands-free-toggle');
            if (handsFreeToggle) {
                handsFreeToggle.addEventListener('click', toggleHandsFree);
            }
            
            // Sources button
            const sourcesBtn = document.getElementById('sources-btn');
            if (sourcesBtn) {
                sourcesBtn.addEventListener('click', showSources);
            }
        }

        function toggleLiveMute() {
            isLiveMuted = !isLiveMuted;
            
            if (liveMuteBtn) {
                if (isLiveMuted) {
                    liveMuteBtn.classList.add('muted');
                    liveMuteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                    updateConversationStatus('Muted', 'Microphone is off');
                } else {
                    liveMuteBtn.classList.remove('muted');
                    liveMuteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                    updateConversationStatus('Listening', 'Speak naturally and I\'ll respond');
                }
            }
            
            // Mute/unmute the audio stream
            if (liveMediaStream) {
                liveMediaStream.getAudioTracks().forEach(track => {
                    track.enabled = !isLiveMuted;
                });
            }
        }

        function updateConversationStatus(title, subtitle) {
            // Use the transcription text element to show status
            const transcriptionText = document.getElementById('transcription-text');
            if (transcriptionText) {
                if (subtitle) {
                    transcriptionText.textContent = `${title}: ${subtitle}`;
                } else {
                    transcriptionText.textContent = title;
                }
            }
            console.log(`Status: ${title}${subtitle ? ` - ${subtitle}` : ''}`);
        }

        async function initializeLiveAudio() {
            try {
                // Get microphone access
                liveMediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                // Create audio context for visualization
                liveAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                liveAnalyser = liveAudioContext.createAnalyser();
                liveAnalyser.fftSize = 256;
                
                const source = liveAudioContext.createMediaStreamSource(liveMediaStream);
                source.connect(liveAnalyser);
                
                // Initialize ElevenLabs Live API connection
                await initializeElevenLabsLive();
                
                updateConversationStatus('Ready', 'ElevenLabs AI agent is ready to listen and support you');
                
            } catch (error) {
                console.error('Error initializing live audio:', error);
                updateConversationStatus('Error', 'Could not access microphone');
            }
        }

        async function initializeElevenLabsLive() {
            try {
                console.log('Initializing ElevenLabs Conversational AI...');
                updateConversationStatus('Connecting...', 'Establishing secure connection');
                
                // Check if socket is connected
                if (!socket || !socket.connected) {
                    throw new Error('Socket.IO connection not available');
                }
                
                // Use SocketIO to start live session through backend
                console.log('Starting ElevenLabs live session via SocketIO...');
                socket.emit('live_session_start', {
                    agent_id: 'default'  // Use default ElevenLabs agent
                });
                
                console.log('✅ ElevenLabs Live session start request sent via SocketIO');
                
            } catch (error) {
                console.error('❌ Error connecting to ElevenLabs Live:', error);
                updateConversationStatus('Connection Error', error.message || 'Please try again later');
                throw error;
            }
        }

        // ElevenLabs uses SocketIO connection - no need for separate token management

        // ElevenLabs connection is handled via SocketIO in the backend

        // ElevenLabs event handlers are set up through SocketIO in the main script
        // Audio responses will be handled via the live_audio_response event
        // Text responses will be handled via the live_text_response event

        // Audio Processing Setup
        function setupAudioProcessing() {
            if (!liveMediaStream) {
                console.warn('No media stream available for audio processing');
                return;
            }
            
            // Create audio processing pipeline
            const audioContext = liveAudioContext;
            const source = audioContext.createMediaStreamSource(liveMediaStream);
            
            // Create script processor for real-time audio capture
            const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            
            // Voice Activity Detection
            let voiceActivityTimeout;
            let isUserSpeaking = false;
            let audioBuffer = [];
            let silenceCount = 0;
            
            scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                if (isLiveMuted) return;
                
                const inputBuffer = audioProcessingEvent.inputBuffer;
                const inputData = inputBuffer.getChannelData(0);
                
                // Convert to 16kHz PCM for audio processing
                const downsampledData = downsampleAudio(inputData, audioContext.sampleRate, 16000);
                
                // Voice Activity Detection
                const rms = calculateRMS(downsampledData);
                const isVoiceDetected = rms > 0.01; // Threshold for voice detection
                
                if (isVoiceDetected) {
                    if (!isUserSpeaking) {
                        isUserSpeaking = true;
                        console.log('🎤 User started speaking');
                        updateConversationStatus('Listening', 'I hear you...');
                        triggerUserSpeakingVisuals();
                    }
                    
                    // Add to buffer
                    audioBuffer.push(...downsampledData);
                    silenceCount = 0;
                    
                    // Clear any existing timeout
                    if (voiceActivityTimeout) {
                        clearTimeout(voiceActivityTimeout);
                    }
                    
                    // Set timeout for end of speech
                    voiceActivityTimeout = setTimeout(() => {
                        if (isUserSpeaking && audioBuffer.length > 0) {
                            console.log('🔇 User stopped speaking, sending audio');
                            sendAudioToElevenLabs(audioBuffer);
                            audioBuffer = [];
                            isUserSpeaking = false;
                            triggerIdleVisuals();
                        }
                    }, 1000); // 1 second of silence
                    
                } else {
                    silenceCount++;
                    
                    // If we have enough silence samples, consider speech ended
                    if (isUserSpeaking && silenceCount > 20) { // ~0.5 seconds of silence
                        if (voiceActivityTimeout) {
                            clearTimeout(voiceActivityTimeout);
                        }
                        
                        if (audioBuffer.length > 0) {
                            console.log('🔇 User finished speaking');
                            sendAudioToElevenLabs(audioBuffer);
                            audioBuffer = [];
                            isUserSpeaking = false;
                            triggerIdleVisuals();
                        }
                    }
                }
            };
            
            // Connect the audio processing pipeline
            source.connect(scriptProcessor);
            scriptProcessor.connect(audioContext.destination);
            
            console.log('🎵 Audio processing pipeline established');
        }

        // Send audio data for STT processing
        function sendAudioToElevenLabs(audioData) {
            if (!liveSessionId || !isLiveSessionActive) {
                console.log('⚠️ No active session for audio processing');
                return;
            }
            
            try {
                // Convert Float32Array to base64
                const audioBuffer = new ArrayBuffer(audioData.length * 4);
                const audioView = new Float32Array(audioBuffer);
                audioView.set(audioData);
                
                // Convert to base64
                const bytes = new Uint8Array(audioBuffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                const audioBase64 = btoa(binary);
                
                console.log('🎤 Sending audio for STT processing');
                
                // Send to backend for STT processing
                socket.emit('live_send_audio', {
                    session_id: liveSessionId,
                    audio_data: audioBase64
                });
                
                updateConversationStatus('Processing...', 'Converting speech to text');
                
            } catch (error) {
                console.error('Error sending audio:', error);
                updateConversationStatus('Error', 'Failed to process audio');
            }
        }

        // Play AI response audio (legacy PCM format)
        async function playAIResponse(audioBase64) {
            try {
                // Decode base64 audio data
                const audioData = atob(audioBase64);
                const audioArray = new Uint8Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    audioArray[i] = audioData.charCodeAt(i);
                }
                
                // Convert PCM to playable audio
                const audioBuffer = await liveAudioContext.decodeAudioData(audioArray.buffer);
                
                // Create audio source and play
                const source = liveAudioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(liveAudioContext.destination);
                source.start();
                
                console.log('🔊 Playing AI response audio');
                
            } catch (error) {
                console.error('Error playing AI response:', error);
            }
        }

        // Play ElevenLabs audio response
        function playElevenLabsAudio(audioBase64) {
            try {
                // Don't play if audio is muted
                if (isAudioMuted) {
                    console.log('🔇 Audio muted, skipping playback');
                    return;
                }
                
                // Create an audio element for ElevenLabs MP3 audio
                const audio = new Audio();
                audio.src = 'data:audio/mp3;base64,' + audioBase64;
                audio.volume = 1.0;
                
                audio.onloadeddata = () => {
                    audio.play().then(() => {
                        console.log('🔊 Playing ElevenLabs audio response');
                    }).catch(error => {
                        console.error('Failed to play ElevenLabs audio:', error);
                        // Request user interaction for autoplay
                        updateConversationStatus('Audio Ready', 'Click anywhere to enable audio playback');
                        document.addEventListener('click', () => audio.play(), { once: true });
                        if (voiceSphereSystem) {
                            voiceSphereSystem.setMode('idle');
                        }
                    });
                };
                
                audio.onended = () => {
                    console.log('ElevenLabs audio finished playing');
                    if (voiceSphereSystem) {
                        voiceSphereSystem.setMode('idle');
                    }
                };
                
                audio.onerror = (error) => {
                    console.error('ElevenLabs audio error:', error);
                    if (voiceSphereSystem) {
                        voiceSphereSystem.setMode('idle');
                    }
                };
                
            } catch (error) {
                console.error('Failed to process ElevenLabs audio:', error);
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('idle');
                }
            }
        }

        // Configure AI personality for mindfulness/emotional support
        async function configureAIPersonality() {
            // Additional configuration can be sent after initial setup
            const personalityConfig = {
                clientContent: {
                    turns: [{
                        role: "user",
                        parts: [{
                            text: "Please remember that you are a mindful, emotionally supportive companion. Always respond with warmth, empathy, and presence. Use natural speech patterns with appropriate pauses for reflection."
                        }]
                    }]
                }
            };
            
            if (liveWebSocket && liveWebSocket.readyState === WebSocket.OPEN) {
                liveWebSocket.send(JSON.stringify(personalityConfig));
            }
        }

        // Audio utility functions
        function downsampleAudio(inputData, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) return inputData;
            
            const ratio = inputSampleRate / outputSampleRate;
            const outputLength = Math.floor(inputData.length / ratio);
            const output = new Float32Array(outputLength);
            
            for (let i = 0; i < outputLength; i++) {
                const inputIndex = Math.floor(i * ratio);
                output[i] = inputData[inputIndex];
            }
            
            return output;
        }

        function calculateRMS(audioData) {
            let sum = 0;
            for (let i = 0; i < audioData.length; i++) {
                sum += audioData[i] * audioData[i];
            }
            return Math.sqrt(sum / audioData.length);
        }

        // Visual feedback functions for particle system
        function triggerUserSpeakingVisuals() {
            if (particleSystem) {
                particleSystem.setMode('user_speaking');
            }
        }

        function triggerAIResponseVisuals() {
            if (particleSystem) {
                particleSystem.setMode('ai_responding');
            }
            updateConversationStatus('AI Speaking', 'Sharing thoughts with care...');
        }

        function triggerIdleVisuals() {
            if (particleSystem) {
                particleSystem.setMode('idle');
            }
        }

        // Enhanced error handling and reconnection logic for ElevenLabs
        function handleElevenLabsError(error) {
            console.error('ElevenLabs Live API Error:', error);
            
            const errorMessages = {
                'auth_failed': 'Authentication failed. Please refresh and try again.',
                'quota_exceeded': 'API quota exceeded. Please try again later.',
                'network_error': 'Network connection issue. Checking connection...',
                'invalid_audio': 'Audio format issue. Please check your microphone.',
                'default': 'Connection issue. Attempting to reconnect...'
            };
            
            const message = errorMessages[error.type] || errorMessages.default;
            updateConversationStatus('Error', message);
            
            // Implement exponential backoff for reconnection
            if (error.retryable && isLiveConversationActive) {
                setTimeout(() => {
                    if (isLiveConversationActive) {
                        initializeElevenLabsLive().catch(retryError => {
                            console.error('Retry failed:', retryError);
                        });
                    }
                }, Math.min(30000, 1000 * Math.pow(2, error.retryCount || 0)));
            }
        }

        // Perplexity-style Voice Sphere Functions
        let voiceSphereSystem = null;
        let isHandsFreeMode = false;
        let speechRecognition = null;

        function initializeVoiceSphere() {
            const voiceSphere = document.getElementById('voice-sphere');
            const shiftingDots = document.getElementById('shifting-dots');
            if (!voiceSphere || !shiftingDots) return;

            // Create Perplexity-style dot pattern
            const totalDots = 180; // Increased for denser pattern
            const centerX = 150;
            const centerY = 150;
            const dots = [];

            // Create dots in multiple rings + scattered pattern
            for (let i = 0; i < totalDots; i++) {
                const dot = document.createElement('div');
                dot.className = 'voice-dot';
                
                let x, y, radius, angle;
                
                // Distribution: 60% outer ring, 30% middle rings, 10% scattered
                const distribution = i / totalDots;
                
                if (distribution < 0.6) {
                    // Outer ring with slight variation
                    angle = (i / (totalDots * 0.6)) * Math.PI * 2;
                    radius = 110 + Math.random() * 10;
                } else if (distribution < 0.9) {
                    // Middle rings
                    angle = ((i - totalDots * 0.6) / (totalDots * 0.3)) * Math.PI * 2;
                    radius = 40 + Math.random() * 60;
                } else {
                    // Scattered inner dots
                    angle = Math.random() * Math.PI * 2;
                    radius = Math.random() * 40;
                }
                
                x = centerX + Math.cos(angle) * radius;
                y = centerY + Math.sin(angle) * radius;
                
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                
                // Store dot data
                const dotData = {
                    element: dot,
                    baseX: x,
                    baseY: y,
                    currentX: x,
                    currentY: y,
                    angle: angle,
                    radius: radius,
                    speed: 0.3 + Math.random() * 0.7,
                    phaseOffset: Math.random() * Math.PI * 2,
                    floatAmplitude: 0.5 + Math.random() * 1.5,
                    responseStrength: 0.5 + Math.random() * 0.5
                };
                
                dots.push(dotData);
                shiftingDots.appendChild(dot);
            }

            // Setup mouse/touch interactions
            const setupInteractions = () => {
                let mousePosition = { x: 0, y: 0 };

                // Mouse/touch interaction for scatter effect
                voiceSphere.addEventListener('mousemove', (e) => {
                    const rect = voiceSphere.getBoundingClientRect();
                    mousePosition = {
                        x: e.clientX - rect.left - 150,
                        y: e.clientY - rect.top - 150
                    };
                    scatterNearbyDots(mousePosition);
                });

                voiceSphere.addEventListener('mouseleave', () => {
                    mousePosition = { x: 0, y: 0 };
                    resetDots();
                });

                // Touch interactions
                voiceSphere.addEventListener('touchmove', (e) => {
                    const rect = voiceSphere.getBoundingClientRect();
                    const touch = e.touches[0];
                    mousePosition = {
                        x: touch.clientX - rect.left - 150,
                        y: touch.clientY - rect.top - 150
                    };
                    scatterNearbyDots(mousePosition);
                });

                voiceSphere.addEventListener('touchend', () => {
                    mousePosition = { x: 0, y: 0 };
                    resetDots();
                });

                // Click for pulse effect and start live session
                voiceSphere.addEventListener('click', async () => {
                    createRipple();
                    
                    // If session is not active, start one
                    if (!sessionActive) {
                        try {
                            // Request microphone permission first
                            await navigator.mediaDevices.getUserMedia({ audio: true });
                            
                            // Initialize ElevenLabs Live session
                            await initializeElevenLabsLive();
                        } catch (error) {
                            console.error('Error starting live session:', error);
                            updateConversationStatus('Permission Required', 'Please allow microphone access');
                        }
                    }
                });

                const scatterNearbyDots = (mousePos) => {
                    const scatterRadius = 50;
                    
                    dots.forEach(dot => {
                        const dx = dot.currentX - 150 - mousePos.x;
                        const dy = dot.currentY - 150 - mousePos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < scatterRadius) {
                            const force = 1 - (distance / scatterRadius);
                            const scatterX = dx * force * 30;
                            const scatterY = dy * force * 30;
                            
                            dot.element.style.setProperty('--scatter-x', `${scatterX}px`);
                            dot.element.style.setProperty('--scatter-y', `${scatterY}px`);
                            dot.element.classList.add('scattered');
                            
                            // Update position with scatter
                            const newX = dot.baseX + scatterX * 0.3;
                            const newY = dot.baseY + scatterY * 0.3;
                            dot.element.style.transform = `translate(${newX - dot.baseX}px, ${newY - dot.baseY}px)`;
                        }
                    });
                };

                const resetDots = () => {
                    dots.forEach(dot => {
                        dot.element.classList.remove('scattered');
                        dot.element.style.transform = '';
                    });
                };

                const createRipple = () => {
                    dots.forEach((dot, index) => {
                        setTimeout(() => {
                            dot.element.style.animation = 'ripple 0.8s ease-out';
                            setTimeout(() => {
                                dot.element.style.animation = '';
                            }, 800);
                        }, index * 2);
                    });
                };
            };

            setupInteractions();

            // Enhanced animation system
            voiceSphereSystem = {
                dots: dots,
                animationId: null,
                mode: 'idle',
                time: 0,
                audioLevel: 0,
                
                start() {
                    this.animate();
                },
                
                stop() {
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                },
                
                setMode(newMode) {
                    this.mode = newMode;
                    
                    this.dots.forEach(dot => {
                        dot.element.classList.remove('active', 'ai-speaking');
                        
                        if (newMode === 'user_speaking') {
                            dot.element.classList.add('active');
                        } else if (newMode === 'ai_responding') {
                            dot.element.classList.add('ai-speaking');
                        }
                    });
                },
                
                animate() {
                    this.time += 0.016; // Assuming 60fps
                    
                    this.dots.forEach(dot => {
                        let x = dot.baseX;
                        let y = dot.baseY;
                        
                        // Base floating animation
                        const floatX = Math.sin(this.time * dot.speed + dot.phaseOffset) * dot.floatAmplitude;
                        const floatY = Math.cos(this.time * dot.speed * 0.7 + dot.phaseOffset) * dot.floatAmplitude;
                        
                        // Mode-specific animations
                        if (this.mode === 'idle') {
                            // Gentle circular motion
                            const breathe = Math.sin(this.time * 0.5) * 2;
                            x += floatX + Math.cos(dot.angle + this.time * 0.1) * breathe;
                            y += floatY + Math.sin(dot.angle + this.time * 0.1) * breathe;
                            
                        } else if (this.mode === 'user_speaking') {
                            // Inward contraction with audio response
                            const contraction = 0.7 + Math.sin(this.time * 3) * 0.1 + this.audioLevel * 0.2;
                            const newRadius = dot.radius * contraction;
                            x = 150 + Math.cos(dot.angle) * newRadius;
                            y = 150 + Math.sin(dot.angle) * newRadius;
                            
                            // Add vibration based on audio
                            x += Math.random() * this.audioLevel * 10 - 5;
                            y += Math.random() * this.audioLevel * 10 - 5;
                            
                        } else if (this.mode === 'ai_responding') {
                            // Outward expansion with rhythmic pulse
                            const expansion = 1.2 + Math.sin(this.time * 2 + dot.phaseOffset) * 0.15;
                            const newRadius = dot.radius * expansion;
                            x = 150 + Math.cos(dot.angle + this.time * 0.2) * newRadius;
                            y = 150 + Math.sin(dot.angle + this.time * 0.2) * newRadius;
                            
                            // Add flowing motion
                            x += Math.sin(this.time * 1.5 + dot.phaseOffset) * 3;
                            y += Math.cos(this.time * 1.5 + dot.phaseOffset) * 3;
                        }
                        
                        // Apply smooth transition
                        dot.currentX = dot.currentX + (x - dot.currentX) * 0.1;
                        dot.currentY = dot.currentY + (y - dot.currentY) * 0.1;
                        
                        // Don't override scatter transform if active
                        if (!dot.element.classList.contains('scattered')) {
                            dot.element.style.transform =
                                `translate(${dot.currentX - dot.baseX}px, ${dot.currentY - dot.baseY}px)`;
                        }
                        
                        // Dynamic opacity
                        const baseOpacity = this.mode === 'idle' ? 0.5 : 0.8;
                        const opacityVariation = Math.sin(this.time * dot.speed * 2 + dot.phaseOffset) * 0.2;
                        dot.element.style.opacity = baseOpacity + opacityVariation;
                    });
                    
                    this.animationId = requestAnimationFrame(() => this.animate());
                },

                // Simulate audio level for demo
                simulateAudioLevel() {
                    if (this.mode === 'user_speaking') {
                        this.audioLevel = 0.3 + Math.random() * 0.7;
                    } else {
                        this.audioLevel = Math.max(0, this.audioLevel - 0.05);
                    }
                }
            };
            
            voiceSphereSystem.start();
        }

        function toggleLiveRecording() {
            if (isLiveRecording) {
                stopLiveRecording();
            } else {
                startLiveRecording();
            }
        }

        async function startLiveRecording() {
            if (isLiveRecording) return;
            
            try {
                // Get microphone access
                liveMediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                });
                
                // Setup audio context and analyser for VAD
                liveAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = liveAudioContext.createMediaStreamSource(liveMediaStream);
                liveAnalyser = liveAudioContext.createAnalyser();
                liveAnalyser.fftSize = 256;
                source.connect(liveAnalyser);
                
                // Setup modern audio processing (fallback to ScriptProcessor if needed)
                audioBuffer = [];
                isLiveRecording = true;
                isListeningForSilence = true;
                
                // Update UI
                const micBtn = document.getElementById('live-mic-btn');
                if (micBtn) {
                    micBtn.classList.add('recording');
                    micBtn.title = 'Recording... Click to stop';
                }
                
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('user_speaking');
                }
                
                updateTranscriptionText('Listening');
                
                // Use MediaRecorder for better compatibility
                try {
                    const mediaRecorder = new MediaRecorder(liveMediaStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    const audioChunks = [];
                    
                    mediaRecorder.ondataavailable = function(event) {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = function() {
                        if (audioChunks.length > 0) {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            processAudioBlob(audioBlob);
                            audioChunks.length = 0;
                        }
                    };
                    
                    // Store for cleanup
                    window.currentMediaRecorder = mediaRecorder;
                    
                    // Start recording
                    mediaRecorder.start(100); // Collect data every 100ms
                    
                    // Start VAD detection separately
                    startVADDetection();
                    
                } catch (e) {
                    console.warn('MediaRecorder not available, falling back to ScriptProcessor:', e);
                    // Fallback to ScriptProcessor
                    audioProcessor = liveAudioContext.createScriptProcessor(4096, 1, 1);
                    source.connect(audioProcessor);
                    audioProcessor.connect(liveAudioContext.destination);
                    
                    // Process audio data
                    audioProcessor.onaudioprocess = function(e) {
                        if (!isLiveRecording) return;
                        
                        const inputData = e.inputBuffer.getChannelData(0);
                        audioBuffer.push(new Float32Array(inputData));
                        
                        // Voice Activity Detection
                        detectVoiceActivity();
                    };
                }
                
                console.log('Live recording started');
                
            } catch (error) {
                console.error('Error starting live recording:', error);
                updateTranscriptionText('❌ Microphone access denied');
            }
        }

        function stopLiveRecording() {
            if (!isLiveRecording) return;
            
            isLiveRecording = false;
            isListeningForSilence = false;
            
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
            
            // Update UI
            const micBtn = document.getElementById('live-mic-btn');
            if (micBtn) {
                micBtn.classList.remove('recording', 'listening');
                micBtn.title = 'Push to Talk';
            }
            
            // Stop audio processing
            if (window.currentMediaRecorder) {
                window.currentMediaRecorder.stop();
                window.currentMediaRecorder = null;
            }
            
            if (audioProcessor) {
                audioProcessor.disconnect();
                audioProcessor = null;
            }
            
            if (liveAudioContext) {
                liveAudioContext.close();
                liveAudioContext = null;
            }
            
            if (liveMediaStream) {
                liveMediaStream.getTracks().forEach(track => track.stop());
                liveMediaStream = null;
            }
            
            if (voiceSphereSystem) {
                voiceSphereSystem.setMode('idle');
            }
            
            // Process recorded audio if we have any
            if (audioBuffer.length > 0) {
                processRecordedAudio();
            } else {
                updateTranscriptionText('🎤 Click to start speaking...');
            }
            
            console.log('Live recording stopped');
        }

        function detectVoiceActivity() {
            if (!liveAnalyser || !isLiveRecording) return;
            
            const dataArray = new Uint8Array(liveAnalyser.frequencyBinCount);
            liveAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate average amplitude
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            
            // Voice activity threshold (adjust as needed)
            const voiceThreshold = 25;
            const silenceThreshold = 15;
            
            if (average > voiceThreshold) {
                // Voice detected
                if (!isListeningForSilence) {
                    isListeningForSilence = true;
                    updateTranscriptionText('🎤 Speaking detected...');
                }
                
                // Clear silence timer
                if (silenceTimer) {
                    clearTimeout(silenceTimer);
                    silenceTimer = null;
                }
                
            } else if (average < silenceThreshold && isListeningForSilence) {
                // Potential silence
                if (!silenceTimer) {
                    silenceTimer = setTimeout(() => {
                        // Silence detected for 1.5 seconds
                        updateTranscriptionText('🤔 Processing...');
                        stopLiveRecording();
                    }, 1500);
                }
            }
        }

        async function processRecordedAudio() {
            if (audioBuffer.length === 0) return;
            
            try {
                updateTranscriptionText('🔄 Converting speech to text...');
                
                // Convert audio buffer to WAV format
                const audioData = mergeAudioBuffers(audioBuffer);
                const wavBlob = createWavBlob(audioData, 44100);
                
                // Convert to base64 for transmission (chunk-wise to avoid stack overflow)
                const arrayBuffer = await wavBlob.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Process in chunks to avoid "Maximum call stack size exceeded"
                let binaryString = '';
                const chunkSize = 8192;
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.slice(i, i + chunkSize);
                    binaryString += String.fromCharCode.apply(null, chunk);
                }
                const base64Audio = btoa(binaryString);
                
                // Send to STT
                socket.emit('live_send_audio', {
                    audio_data: base64Audio,
                    format: 'wav'
                });
                
                audioBuffer = [];
                
            } catch (error) {
                console.error('Error processing audio:', error);
                updateTranscriptionText('❌ Error processing audio');
            }
        }

        function mergeAudioBuffers(buffers) {
            let totalLength = 0;
            for (let buffer of buffers) {
                totalLength += buffer.length;
            }
            
            const result = new Float32Array(totalLength);
            let offset = 0;
            for (let buffer of buffers) {
                result.set(buffer, offset);
                offset += buffer.length;
            }
            
            return result;
        }

        function createWavBlob(audioData, sampleRate) {
            const length = audioData.length;
            const buffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(buffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // Convert float samples to 16-bit PCM
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, audioData[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        function updateTranscriptionText(text) {
            const transcriptionElement = document.getElementById('transcription-text');
            if (transcriptionElement) {
                transcriptionElement.textContent = text;
            }
        }

        function startVADDetection() {
            // Start voice activity detection loop
            function checkVAD() {
                if (isLiveRecording) {
                    detectVoiceActivity();
                    setTimeout(checkVAD, 100); // Check every 100ms
                }
            }
            checkVAD();
        }

        async function processAudioBlob(audioBlob) {
            try {
                updateTranscriptionText('🔄 Converting speech to text...');
                
                // Convert blob to base64
                const arrayBuffer = await audioBlob.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Process in chunks to avoid "Maximum call stack size exceeded"
                let binaryString = '';
                const chunkSize = 8192;
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.slice(i, i + chunkSize);
                    binaryString += String.fromCharCode.apply(null, chunk);
                }
                const base64Audio = btoa(binaryString);
                
                // Send to STT
                socket.emit('live_send_audio', {
                    audio_data: base64Audio,
                    format: 'webm'
                });
                
            } catch (error) {
                console.error('Error processing audio blob:', error);
                updateTranscriptionText('❌ Error processing audio');
            }
        }

        function playAudioChunk(audioBase64) {
            try {
                // Convert base64 to blob URL
                const byteCharacters = atob(audioBase64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const audioBlob = new Blob([byteArray], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Create and play audio element
                const audio = new Audio(audioUrl);
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                };
                audio.play().catch(error => {
                    console.error('Error playing audio chunk:', error);
                });
                
            } catch (error) {
                console.error('Error processing audio chunk:', error);
            }
        }

        function toggleHandsFree() {
            isHandsFreeMode = !isHandsFreeMode;
            const toggle = document.getElementById('hands-free-toggle');
            
            if (toggle) {
                if (isHandsFreeMode) {
                    toggle.classList.add('active');
                    updateConversationStatus('Hands-free Active', 'Just start speaking naturally');
                } else {
                    toggle.classList.remove('active');
                    updateConversationStatus('Ready', 'Press and hold microphone to speak');
                }
            }
            
            return isHandsFreeMode;
        }

        function showSources() {
            alert('Sources feature coming soon!\n\nThis will show the references and sources that the AI uses to generate responses.');
        }

        function updateTranscription(text, isListening = false) {
            const transcriptionText = document.getElementById('transcription-text');
            if (transcriptionText) {
                if (isListening) {
                    transcriptionText.style.color = '#c17b47';
                    transcriptionText.style.fontStyle = 'italic';
                } else {
                    transcriptionText.style.color = '#1a1a1a';
                    transcriptionText.style.fontStyle = 'normal';
                }
                transcriptionText.textContent = text;
            }
        }

        function startSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateTranscription('Speech recognition not supported in this browser');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true;
            speechRecognition.lang = 'en-US';

            speechRecognition.onresult = (event) => {
                let transcript = '';
                let isFinal = false;
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        isFinal = true;
                    }
                }
                
                updateTranscription(transcript || 'Listening...');
                
                // Send final transcript to ElevenLabs agent
                if (isFinal && transcript.trim() && sessionActive && currentSessionId) {
                    console.log('Sending speech to ElevenLabs:', transcript);
                    socket.emit('live_send_text', {
                        session_id: currentSessionId,
                        message: transcript.trim()
                    });
                }
            };

            speechRecognition.onerror = (event) => {
                updateTranscription('Error: ' + event.error);
            };

            speechRecognition.start();
        }

        function stopSpeechRecognition() {
            if (speechRecognition) {
                speechRecognition.stop();
                speechRecognition = null;
            }
        }

        function initializeParticleSystem() {
            if (!particleCanvas) return;
            
            const ctx = particleCanvas.getContext('2d');
            const canvas = particleCanvas;
            
            // Set canvas size
            canvas.width = 400;
            canvas.height = 400;
            
            // Particle system state
            const particles = [];
            const particleCount = 100;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = 80;
            
            let currentMode = 'idle';
            let audioLevel = 0;
            let animationId;
            let modeTransition = 0; // 0-1 for smooth transitions
            
            // Create particles
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    angle: (i / particleCount) * Math.PI * 2,
                    baseRadius: baseRadius + Math.random() * 20,
                    currentRadius: baseRadius + Math.random() * 20,
                    targetRadius: baseRadius + Math.random() * 20,
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 0.02 + 0.01,
                    alpha: Math.random() * 0.5 + 0.3,
                    pulseOffset: Math.random() * Math.PI * 2,
                    color: { r: 193, g: 123, b: 71 }
                });
            }
            
            function updateParticleTargets(mode) {
                particles.forEach((particle) => {
                    switch (mode) {
                        case 'user_speaking':
                            // Particles move inward when user speaks
                            particle.targetRadius = particle.baseRadius * 0.6;
                            particle.color = { r: 100, g: 150, b: 200 }; // Cool blue for user
                            break;
                        case 'ai_responding':
                            // Particles expand outward when AI responds
                            particle.targetRadius = particle.baseRadius * 1.4;
                            particle.color = { r: 193, g: 123, b: 71 }; // App primary color
                            break;
                        case 'idle':
                        default:
                            // Gentle breathing motion when idle
                            particle.targetRadius = particle.baseRadius;
                            particle.color = { r: 160, g: 160, b: 160 }; // Subtle gray
                            break;
                    }
                });
            }
            
            function animate() {
                if (!isLiveConversationActive) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get audio level if analyzer is available
                if (liveAnalyser && !isLiveMuted) {
                    const dataArray = new Uint8Array(liveAnalyser.frequencyBinCount);
                    liveAnalyser.getByteFrequencyData(dataArray);
                    audioLevel = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length / 255;
                }
                
                // Update mode transition for smooth animations
                modeTransition = Math.min(1, modeTransition + 0.05);
                
                // Draw particles
                particles.forEach((particle, index) => {
                    // Smooth transition to target radius
                    const radiusDiff = particle.targetRadius - particle.currentRadius;
                    particle.currentRadius += radiusDiff * 0.1;
                    
                    // Update angle
                    particle.angle += particle.speed;
                    
                    // Calculate position with audio responsiveness
                    let currentRadius = particle.currentRadius;
                    
                    if (currentMode === 'user_speaking' && audioLevel > 0) {
                        // Add audio-reactive scaling for user speech
                        currentRadius *= (0.9 + audioLevel * 0.3);
                    } else if (currentMode === 'ai_responding') {
                        // Gentle pulsing for AI response
                        const pulse = Math.sin(Date.now() * 0.004 + particle.pulseOffset) * 0.15;
                        currentRadius *= (1 + pulse);
                    } else if (currentMode === 'idle') {
                        // Subtle breathing motion when idle
                        const breathe = Math.sin(Date.now() * 0.002 + particle.pulseOffset) * 0.05;
                        currentRadius *= (1 + breathe);
                    }
                    
                    const x = centerX + Math.cos(particle.angle) * currentRadius;
                    const y = centerY + Math.sin(particle.angle) * currentRadius;
                    
                    // Calculate alpha based on mode and audio level
                    let alpha = particle.alpha;
                    if (currentMode === 'user_speaking' && audioLevel > 0) {
                        alpha = Math.min(1, particle.alpha * (1 + audioLevel * 2));
                    } else if (currentMode === 'ai_responding') {
                        alpha = particle.alpha * (0.8 + Math.sin(Date.now() * 0.005 + particle.pulseOffset) * 0.3);
                    }
                    
                    // Interpolate color
                    const r = Math.floor(particle.color.r * modeTransition + 255 * (1 - modeTransition));
                    const g = Math.floor(particle.color.g * modeTransition + 255 * (1 - modeTransition));
                    const b = Math.floor(particle.color.b * modeTransition + 255 * (1 - modeTransition));
                    
                    // Draw particle with glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.fill();
                    
                    // Add inner glow
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, ${alpha * 0.8})`;
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                });
                
                // Draw central core
                const coreSize = currentMode === 'user_speaking' ? 8 + audioLevel * 10 : 
                                currentMode === 'ai_responding' ? 10 + Math.sin(Date.now() * 0.01) * 3 : 
                                6 + Math.sin(Date.now() * 0.003) * 2;
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = currentMode === 'user_speaking' ? 'rgba(100, 150, 200, 0.8)' :
                                 currentMode === 'ai_responding' ? 'rgba(193, 123, 71, 0.8)' :
                                 'rgba(160, 160, 160, 0.6)';
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                ctx.fillStyle = currentMode === 'user_speaking' ? 'rgba(100, 150, 200, 0.9)' :
                               currentMode === 'ai_responding' ? 'rgba(193, 123, 71, 0.9)' :
                               'rgba(160, 160, 160, 0.8)';
                ctx.fill();
                ctx.shadowBlur = 0;
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
            
            // Store particle system for cleanup and mode control
            particleSystem = {
                setMode: (mode) => {
                    if (mode !== currentMode) {
                        currentMode = mode;
                        modeTransition = 0;
                        updateParticleTargets(mode);
                        console.log(`🎨 Particle system mode: ${mode}`);
                    }
                },
                stop: () => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                },
                getMode: () => currentMode
            };
        }

        // Initialize Socket.IO connection for live conversation
        let socket = null;
        let currentSessionId = null;
        let sessionActive = false;

        // Initialize socket connection
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', function() {
                console.log('Connected to server');
                console.log('Socket ID:', socket.id);
            });

            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                if (sessionActive) {
                    updateConversationStatus('Connection Lost', 'Attempting to reconnect...');
                }
            });

            // Live session events
            socket.on('live_session_created', function(data) {
                console.log('Live session created:', data);
                currentSessionId = data.session_id;
                updateConversationStatus('Session Starting...', 'Initializing ElevenLabs conversational AI');
            });

            socket.on('live_session_started', function(data) {
                console.log('Live session started:', data);
                sessionActive = true;
                updateConversationStatus('Ready', 'ElevenLabs AI agent is listening');
            });

            socket.on('live_transcript', function(data) {
                console.log('Received transcript:', data);
                if (data.type === 'user') {
                    updateTranscription('You: ' + data.text);
                }
            });
            
            socket.on('live_text_response', function(data) {
                console.log('Received AI text response:', data);
                // Update transcription with AI response
                updateTranscription('AI: ' + data.text);
                
                // Set voice sphere to AI speaking mode
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('ai_speaking');
                    setTimeout(() => voiceSphereSystem.setMode('idle'), 3000);
                }
            });

            socket.on('live_audio_response', function(data) {
                console.log('Received TTS audio response');
                // Play ElevenLabs TTS audio response
                if (data.audio_data) {
                    playElevenLabsAudio(data.audio_data);
                }
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('ai_speaking');
                }
                
                updateConversationStatus('Speaking', 'AI is responding');
            });

            socket.on('live_text_sent', function(data) {
                console.log('Text sent confirmation:', data);
                updateConversationStatus('Processing', 'Getting AI response...');
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('user_speaking');
                    setTimeout(() => voiceSphereSystem.setMode('idle'), 1000);
                }
            });

            socket.on('live_session_created', function(data) {
                console.log('Live session created:', data);
                updateConversationStatus('Connecting...', 'Session created, establishing connection');
            });
            
            socket.on('live_session_started', function(data) {
                console.log('Live session started:', data);
                
                // Clear timeout
                if (sessionStartTimeout) {
                    clearTimeout(sessionStartTimeout);
                    sessionStartTimeout = null;
                }
                
                updateConversationStatus('Connected', 'Ready to chat! Start speaking or send a text message');
                isLiveSessionActive = true;
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('idle');
                }
            });

            socket.on('live_session_ended', function(data) {
                console.log('Live session ended:', data);
                isLiveSessionActive = false;
                liveSessionId = null;
                updateConversationStatus('Session Ended', 'Thank you for the conversation');
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('idle');
                }
                resetSessionState();
            });

            // New streaming events for STT/TTS system
            socket.on('live_transcript_update', function(data) {
                console.log('Transcript update:', data);
                updateTranscriptionText('🎤 You: ' + data.transcript);
            });
            
            socket.on('live_ai_thinking', function(data) {
                console.log('AI thinking:', data);
                updateTranscriptionText('Thinking');
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('ai_thinking');
                }
            });
            
            socket.on('live_ai_speaking', function(data) {
                console.log('AI speaking:', data);
                updateTranscriptionText('🤖 AI: ');
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('ai_speaking');
                }
            });
            
            socket.on('live_text_chunk', function(data) {
                console.log('Text chunk:', data);
                // Update transcription with streaming text
                updateTranscriptionText('🤖 AI: ' + data.full_text);
            });
            
            socket.on('live_audio_chunk', function(data) {
                console.log('Audio chunk received:', data.text);
                // Play TTS audio chunk immediately
                playAudioChunk(data.audio);
                
                // Make voice sphere react to audio
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('ai_speaking');
                    // Trigger audio reaction animation
                    voiceSphereSystem.triggerAudioReaction();
                }
            });
            
            socket.on('live_audio_received', function(data) {
                console.log('Audio received by server:', data);
                updateTranscriptionText('🔄 Processing audio...');
            });

            socket.on('live_response_complete', function(data) {
                console.log('Response complete:', data);
                updateTranscriptionText('🎤 Click to start speaking...');
                if (voiceSphereSystem) {
                    voiceSphereSystem.setMode('idle');
                }
            });

            socket.on('live_session_error', function(data) {
                console.error('Live session error:', data);
                
                let errorMessage = data.error || 'Connection issue occurred';
                let errorDetail = data.message || '';
                
                // Specific handling for ElevenLabs API issues
                if (errorMessage.includes('ElevenLabs') || errorMessage.includes('API key')) {
                    errorMessage = 'ElevenLabs Not Configured';
                    errorDetail = 'Please set your ELEVENLABS_API_KEY environment variable';
                }
                
                updateConversationStatus(errorMessage, errorDetail);
                isLiveSessionActive = false;
                resetSessionState();
            });
        }

        // New Live Control Functions
        function startLiveSession() {
            console.log('Starting live session...');
            updateConversationStatus('Initializing...', 'Please wait while we establish connection');
            
            // Show/hide appropriate buttons
            // liveStartBtn removed - using mic button only
            if (liveStopBtn) {
                liveStopBtn.style.display = 'flex';
                liveStopBtn.classList.add('active');
            }
            
            // Generate session ID and start ElevenLabs session
            liveSessionId = 'session_' + Date.now();
            
            // Set timeout for session start
            sessionStartTimeout = setTimeout(() => {
                if (!isLiveSessionActive) {
                    console.error('Session start timeout');
                    updateConversationStatus('Connection Timeout', 'Failed to establish connection. Check your ElevenLabs API key.');
                    resetSessionState();
                }
            }, 30000); // 30 second timeout
            
            // Start ElevenLabs session
            socket.emit('live_session_start', { 
                session_id: liveSessionId, 
                agent_id: 'default' 
            });
            
            // Don't set isLiveSessionActive here - wait for live_session_started event
        }
        
        function stopLiveSession() {
            console.log('Stopping live session...');
            updateConversationStatus('Disconnecting...', 'Ending conversation');
            
            // Show/hide appropriate buttons
            // liveStartBtn removed - using mic button only
            if (liveStopBtn) liveStopBtn.style.display = 'none';
            // liveStartBtn removed - using mic button only
            if (liveStopBtn) liveStopBtn.classList.remove('active');
            
            // End ElevenLabs session
            if (liveSessionId) {
                socket.emit('live_session_end', { session_id: liveSessionId });
                liveSessionId = null;
            }
            
            isLiveSessionActive = false;
            updateConversationStatus('Ready', 'Click Start to begin a new conversation');
        }
        
        function toggleAudioMute() {
            isAudioMuted = !isAudioMuted;
            
            if (isAudioMuted) {
                if (liveMuteBtn) {
                    liveMuteBtn.classList.add('muted');
                    const icon = liveMuteBtn.querySelector('i');
                    const span = liveMuteBtn.querySelector('span');
                    if (icon) icon.className = 'fas fa-volume-mute';
                    if (span) span.textContent = 'Unmute';
                }
                updateConversationStatus('Audio Muted', 'You won\'t hear AI responses');
            } else {
                if (liveMuteBtn) {
                    liveMuteBtn.classList.remove('muted');
                    const icon = liveMuteBtn.querySelector('i');
                    const span = liveMuteBtn.querySelector('span');
                    if (icon) icon.className = 'fas fa-volume-up';
                    if (span) span.textContent = 'Mute';
                }
                updateConversationStatus('Audio Enabled', 'You\'ll hear AI responses');
            }
            
            console.log('Audio muted:', isAudioMuted);
        }
        
        function toggleTextInput() {
            if (liveTextInputContainer && liveTextInput && liveSendTextBtn) {
                if (liveTextInputContainer.style.display === 'none' || !liveTextInputContainer.style.display) {
                    liveTextInputContainer.style.display = 'flex';
                    liveTextInput.focus();
                    liveSendTextBtn.classList.add('active');
                } else {
                    liveTextInputContainer.style.display = 'none';
                    liveSendTextBtn.classList.remove('active');
                }
            }
        }
        
        function sendTextMessage() {
            if (!liveTextInput) return;
            
            const message = liveTextInput.value.trim();
            if (!message || !isLiveSessionActive || !liveSessionId) {
                if (!isLiveSessionActive) {
                    updateConversationStatus('Error', 'Please start a session first');
                }
                return;
            }
            
            console.log('Sending text message:', message);
            
            // Send to ElevenLabs
            socket.emit('live_send_text', {
                session_id: liveSessionId,
                message: message
            });
            
            // Clear input and hide
            liveTextInput.value = '';
            if (liveTextInputContainer) liveTextInputContainer.style.display = 'none';
            if (liveSendTextBtn) liveSendTextBtn.classList.remove('active');
            
            // Update transcription to show what user sent
            updateTranscription('You: ' + message);
        }
        
        function resetSessionState() {
            console.log('Resetting session state');
            isLiveSessionActive = false;
            liveSessionId = null;
            
            // Clear any timeouts
            if (sessionStartTimeout) {
                clearTimeout(sessionStartTimeout);
                sessionStartTimeout = null;
            }
            
            // Reset button states
            // liveStartBtn removed - using mic button only
            if (liveStopBtn) {
                liveStopBtn.style.display = 'none';
                liveStopBtn.classList.remove('active');
            }
            if (liveMuteBtn) {
                liveMuteBtn.classList.remove('muted');
                const icon = liveMuteBtn.querySelector('i');
                const span = liveMuteBtn.querySelector('span');
                if (icon) icon.className = 'fas fa-volume-up';
                if (span) span.textContent = 'Mute';
            }
            if (liveTextInputContainer) {
                liveTextInputContainer.style.display = 'none';
            }
            
            isAudioMuted = false;
        }

        // Initialize socket when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize socket after other initializations
            setTimeout(initializeSocket, 1000);
        });

    </script>
    
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>

</body>
</html>